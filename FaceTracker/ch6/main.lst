
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease\main.o:     file format elf32-littlearm
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease\main.o

Disassembly of section .text.DelayMs:

00000000 <DelayMs>:
DelayMs():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:398
void DelayMs( uint16_t delay )
{
	 uint32_t iterations;
	 uint32_t index;
	 
	 iterations = delay*5656;
   0:	f241 6318 	movw	r3, #5656	; 0x1618
   4:	fb03 f300 	mul.w	r3, r3, r0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:400
	 
	 for( index = 0; index < iterations; index++ )
   8:	b123      	cbz	r3, 14 <DelayMs+0x14>
   a:	2200      	movs	r2, #0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:402
	 {
		  asm volatile("mov r0, r0");
   c:	4600      	mov	r0, r0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:400
	 uint32_t iterations;
	 uint32_t index;
	 
	 iterations = delay*5656;
	 
	 for( index = 0; index < iterations; index++ )
   e:	3201      	adds	r2, #1
  10:	4293      	cmp	r3, r2
  12:	d8fb      	bhi.n	c <DelayMs+0xc>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:404
	 {
		  asm volatile("mov r0, r0");
	 }
}
  14:	4770      	bx	lr
  16:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.DelayUs:

00000000 <DelayUs>:
DelayUs():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:407

void DelayUs( uint16_t delay )
{
   0:	b510      	push	{r4, lr}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:411
	 uint32_t iterations;
	 uint32_t index;
	 
	 iterations = delay*5.656;
   2:	f7ff fffe 	bl	0 <__aeabi_i2d>
   6:	a308      	add	r3, pc, #32	(adr r3, 28 <DelayUs+0x28>)
   8:	e9d3 2300 	ldrd	r2, r3, [r3]
   c:	f7ff fffe 	bl	0 <__aeabi_dmul>
  10:	f7ff fffe 	bl	0 <__aeabi_d2uiz>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:413
	 
	 for( index = 0; index < iterations; index++ )
  14:	4602      	mov	r2, r0
  16:	b120      	cbz	r0, 22 <__aeabi_d2uiz+0x22>
  18:	2300      	movs	r3, #0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:415
	 {
		  asm volatile("mov r0, r0");
  1a:	4600      	mov	r0, r0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:413
	 uint32_t iterations;
	 uint32_t index;
	 
	 iterations = delay*5.656;
	 
	 for( index = 0; index < iterations; index++ )
  1c:	3301      	adds	r3, #1
  1e:	429a      	cmp	r2, r3
  20:	d8fb      	bhi.n	1a <__aeabi_d2uiz+0x1a>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:417
	 {
		  asm volatile("mov r0, r0");
	 }
}
  22:	bd10      	pop	{r4, pc}
  24:	46c0      	nop			(mov r8, r8)
  26:	46c0      	nop			(mov r8, r8)
  28:	76c8b439 	.word	0x76c8b439
  2c:	40169fbe 	.word	0x40169fbe
Disassembly of section .text.hexPrint16:

00000000 <hexPrint16>:
hexPrint16():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:342
}

void hexPrint16( uint16_t byte )
{
	 uint8_t char_data[6];
	 uint8_t n0 = (byte & 0x0F);
   0:	f000 010f 	and.w	r1, r0, #15	; 0xf
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:340
	 
	 USART1_transmit( char_data, 4 );	 	 
}

void hexPrint16( uint16_t byte )
{
   4:	b500      	push	{lr}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:343
	 uint8_t char_data[6];
	 uint8_t n0 = (byte & 0x0F);
	 uint8_t n1 = ((byte >> 4) & 0x0F);
   6:	0903      	lsrs	r3, r0, #4
   8:	f003 030f 	and.w	r3, r3, #15	; 0xf
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:344
	 uint8_t n2 = ((byte >> 8) & 0x0F);
   c:	0a02      	lsrs	r2, r0, #8
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:345
	 uint8_t n3 = ((byte >> 12) & 0x0F);
   e:	0b00      	lsrs	r0, r0, #12
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:347
	 
	 if( n0 < 10 )
  10:	2909      	cmp	r1, #9
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:344
void hexPrint16( uint16_t byte )
{
	 uint8_t char_data[6];
	 uint8_t n0 = (byte & 0x0F);
	 uint8_t n1 = ((byte >> 4) & 0x0F);
	 uint8_t n2 = ((byte >> 8) & 0x0F);
  12:	f002 020f 	and.w	r2, r2, #15	; 0xf
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:349
	 uint8_t n3 = ((byte >> 12) & 0x0F);
	 
	 if( n0 < 10 )
	 {
		  n0 += 48;
  16:	bf94      	ite	ls
  18:	f101 0c30 	addls.w	ip, r1, #48	; 0x30
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:353
	 }
	 else
	 {
		  n0 += 55;
  1c:	f101 0c37 	addhi.w	ip, r1, #55	; 0x37
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:356
	 }
	 
	 if( n1 < 10 )
  20:	2b09      	cmp	r3, #9
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:358
	 {
		  n1 += 48;
  22:	bf94      	ite	ls
  24:	f103 0e30 	addls.w	lr, r3, #48	; 0x30
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:362
	 }
	 else
	 {
		  n1 += 55;
  28:	f103 0e37 	addhi.w	lr, r3, #55	; 0x37
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:365
	 }
	 
	 if( n2 < 10 )
  2c:	2a09      	cmp	r2, #9
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:367
	 {
		  n2 += 48;
  2e:	bf94      	ite	ls
  30:	f102 0130 	addls.w	r1, r2, #48	; 0x30
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:371
	 }
	 else
	 {
		  n2 += 55;
  34:	f102 0137 	addhi.w	r1, r2, #55	; 0x37
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:374
	 }
	 
	 if( n3 < 10 )
  38:	2809      	cmp	r0, #9
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:340
	 
	 USART1_transmit( char_data, 4 );	 	 
}

void hexPrint16( uint16_t byte )
{
  3a:	b083      	sub	sp, #12
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:374
	 else
	 {
		  n2 += 55;
	 }
	 
	 if( n3 < 10 )
  3c:	d915      	bls.n	6a <hexPrint16+0x6a>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:380
	 {
		  n3 += 48;
	 }
	 else
	 {
		  n3 += 55;
  3e:	3037      	adds	r0, #55
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:383
	 }

	 char_data[0] = '0';
  40:	2330      	movs	r3, #48
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:384
	 char_data[1] = 'x';
  42:	2278      	movs	r2, #120
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:385
	 char_data[2] = n3;
  44:	f88d 0004 	strb.w	r0, [sp, #4]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:386
	 char_data[3] = n2;
  48:	f88d 1005 	strb.w	r1, [sp, #5]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:390
	 char_data[4] = n1;
	 char_data[5] = n0;
	 
	 USART1_transmit( char_data, 6 );	 	 
  4c:	f10d 0002 	add.w	r0, sp, #2	; 0x2
  50:	2106      	movs	r1, #6
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:383
	 else
	 {
		  n3 += 55;
	 }

	 char_data[0] = '0';
  52:	f88d 3002 	strb.w	r3, [sp, #2]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:384
	 char_data[1] = 'x';
  56:	f88d 2003 	strb.w	r2, [sp, #3]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:387
	 char_data[2] = n3;
	 char_data[3] = n2;
	 char_data[4] = n1;
  5a:	f88d e006 	strb.w	lr, [sp, #6]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:388
	 char_data[5] = n0;
  5e:	f88d c007 	strb.w	ip, [sp, #7]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:390
	 
	 USART1_transmit( char_data, 6 );	 	 
  62:	f7ff fffe 	bl	0 <USART1_transmit>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:391
}
  66:	b003      	add	sp, #12
  68:	bd00      	pop	{pc}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:376
		  n2 += 55;
	 }
	 
	 if( n3 < 10 )
	 {
		  n3 += 48;
  6a:	3030      	adds	r0, #48
  6c:	e7e8      	b.n	40 <USART1_transmit+0x40>
  6e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.hexPrint8:

00000000 <hexPrint8>:
hexPrint8():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:308
		  EXTI_ClearITPendingBit(EXTI_Line15);
	 }
}

void hexPrint8( uint8_t byte )
{
   0:	b500      	push	{lr}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:310
	 uint8_t char_data[4];
	 uint8_t n0 = (byte & 0x0F);
   2:	f000 030f 	and.w	r3, r0, #15	; 0xf
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:311
	 uint8_t n1 = ((byte >> 4) & 0x0F);
   6:	0900      	lsrs	r0, r0, #4
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:313
	 
	 if( n0 < 10 )
   8:	2b09      	cmp	r3, #9
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:315
	 {
		  n0 += 48;
   a:	bf94      	ite	ls
   c:	f103 0130 	addls.w	r1, r3, #48	; 0x30
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:319
	 }
	 else
	 {
		  n0 += 55;
  10:	f103 0137 	addhi.w	r1, r3, #55	; 0x37
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:322
	 }
	 
	 if( n1 < 10 )
  14:	2809      	cmp	r0, #9
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:308
		  EXTI_ClearITPendingBit(EXTI_Line15);
	 }
}

void hexPrint8( uint8_t byte )
{
  16:	b083      	sub	sp, #12
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:322
	 else
	 {
		  n0 += 55;
	 }
	 
	 if( n1 < 10 )
  18:	d910      	bls.n	3c <hexPrint8+0x3c>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:328
	 {
		  n1 += 48;
	 }
	 else
	 {
		  n1 += 55;
  1a:	3037      	adds	r0, #55
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:331
	 }

	 char_data[0] = '0';
  1c:	2330      	movs	r3, #48
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:332
	 char_data[1] = 'x';
  1e:	2278      	movs	r2, #120
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:333
	 char_data[2] = n1;
  20:	f88d 0006 	strb.w	r0, [sp, #6]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:334
	 char_data[3] = n0;
  24:	f88d 1007 	strb.w	r1, [sp, #7]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:336
	 
	 USART1_transmit( char_data, 4 );	 	 
  28:	a801      	add	r0, sp, #4
  2a:	2104      	movs	r1, #4
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:331
	 else
	 {
		  n1 += 55;
	 }

	 char_data[0] = '0';
  2c:	f88d 3004 	strb.w	r3, [sp, #4]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:332
	 char_data[1] = 'x';
  30:	f88d 2005 	strb.w	r2, [sp, #5]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:336
	 char_data[2] = n1;
	 char_data[3] = n0;
	 
	 USART1_transmit( char_data, 4 );	 	 
  34:	f7ff fffe 	bl	0 <USART1_transmit>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:337
}
  38:	b003      	add	sp, #12
  3a:	bd00      	pop	{pc}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:324
		  n0 += 55;
	 }
	 
	 if( n1 < 10 )
	 {
		  n1 += 48;
  3c:	3030      	adds	r0, #48
  3e:	e7ed      	b.n	1c <USART1_transmit+0x1c>
Disassembly of section .text.EXTI15_10_IRQHandler:

00000000 <EXTI15_10_IRQHandler>:
EXTI15_10_IRQHandler():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:275
* Description    : External interrupt handler for interupts 15 to 10.  The HMC5843
						 DRDY pin is attached to pin PA15.  When the DRDY pin goes low,
						 the magnetometer has new data to be read.
*******************************************************************************/
void EXTI15_10_IRQHandler( void )
{
   0:	b510      	push	{r4, lr}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:277
	 
	 if(EXTI_GetITStatus(EXTI_Line15) != RESET)
   2:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   6:	f7ff fffe 	bl	0 <EXTI_GetITStatus>
   a:	b148      	cbz	r0, 16 <gHMC_Initialized+0x16>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:279
	 {
		  if( gHMC_Initialized )
   c:	f240 0300 	movw	r3, #0	; 0x0
  10:	f2c0 0300 	movt	r3, #0	; 0x0
  14:	781a      	ldrb	r2, [r3, #0]
  16:	b922      	cbnz	r2, 22 <EXTI15_10_IRQHandler+0x22>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:303
				}
		  }
		 
		  
		  /* Clear the EXTI line pending bit */
		  EXTI_ClearITPendingBit(EXTI_Line15);
  18:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  1c:	f7ff fffe 	bl	0 <EXTI_ClearITPendingBit>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:305
	 }
}
  20:	bd10      	pop	{r4, pc}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:282
	 if(EXTI_GetITStatus(EXTI_Line15) != RESET)
	 {
		  if( gHMC_Initialized )
		  {
				// Get data.  If valid (return val = 1), then process and fill HMC data structure
				if( getHMCData( i2cRxBuf ) )
  22:	f240 0400 	movw	r4, #0	; 0x0
  26:	f2c0 0400 	movt	r4, #0	; 0x0
  2a:	4620      	mov	r0, r4
  2c:	f7ff fffe 	bl	0 <getHMCData>
  30:	2800      	cmp	r0, #0
  32:	d0f1      	beq.n	18 <EXTI15_10_IRQHandler+0x18>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:284
				{
					 gSensorData.new_mag_data = 1;
  34:	f240 0100 	movw	r1, #0	; 0x0
  38:	f2c0 0100 	movt	r1, #0	; 0x0
  3c:	f04f 0301 	mov.w	r3, #1	; 0x1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:287
							 
					 // NED coordinates
					 gSensorData.mag_y = ((i2cRxBuf[0] << 8) | i2cRxBuf[1]);
  40:	7822      	ldrb	r2, [r4, #0]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:284
		  if( gHMC_Initialized )
		  {
				// Get data.  If valid (return val = 1), then process and fill HMC data structure
				if( getHMCData( i2cRxBuf ) )
				{
					 gSensorData.new_mag_data = 1;
  42:	828b      	strh	r3, [r1, #20]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:287
							 
					 // NED coordinates
					 gSensorData.mag_y = ((i2cRxBuf[0] << 8) | i2cRxBuf[1]);
  44:	7863      	ldrb	r3, [r4, #1]
  46:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  4a:	820b      	strh	r3, [r1, #16]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:288
					 gSensorData.mag_x = ((i2cRxBuf[2] << 8) | i2cRxBuf[3]);
  4c:	78a2      	ldrb	r2, [r4, #2]
  4e:	78e3      	ldrb	r3, [r4, #3]
  50:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  54:	81cb      	strh	r3, [r1, #14]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:289
					 gSensorData.mag_z = -((i2cRxBuf[4] << 8) | i2cRxBuf[5]);
  56:	7922      	ldrb	r2, [r4, #4]
  58:	7963      	ldrb	r3, [r4, #5]
  5a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  5e:	425b      	negs	r3, r3
  60:	824b      	strh	r3, [r1, #18]
  62:	e7d9      	b.n	18 <gSensorData+0x18>
Disassembly of section .text.TIM2_IRQHandler:

00000000 <TIM2_IRQHandler>:
TIM2_IRQHandler():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:241
						 While the sampling sampling frequency of the ADC converter
						 remains fixed, data is transmitted at variable rates based
						 on the timer configuration.
*******************************************************************************/
void TIM2_IRQHandler( void )
{
   0:	b570      	push	{r4, r5, r6, lr}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:242
	 if( TIM_GetITStatus(TIM2, TIM_IT_Update ) != RESET )
   2:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
   6:	2101      	movs	r1, #1
   8:	f7ff fffe 	bl	0 <TIM_GetITStatus>
   c:	b160      	cbz	r0, 1c <gConfig+0x1c>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:246
	 {
		  // If in broadcast mode and the gyros have been calibrated, transmit data packet
		  
		  if( (gConfig.broadcast_enabled == MODE_BROADCAST) && gGyrosCalibrated )
   e:	f240 0300 	movw	r3, #0	; 0x0
  12:	f2c0 0300 	movt	r3, #0	; 0x0
  16:	f893 50b8 	ldrb.w	r5, [r3, #184]
  1a:	2d01      	cmp	r5, #1
  1c:	d005      	beq.n	2a <TIM2_IRQHandler+0x2a>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:261
				}

		  }
		  
		  // Clear pending interrupt bit
		  TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
  1e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  22:	2101      	movs	r1, #1
  24:	f7ff fffe 	bl	0 <TIM_ClearITPendingBit>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:263
	 }
}
  28:	bd70      	pop	{r4, r5, r6, pc}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:246
{
	 if( TIM_GetITStatus(TIM2, TIM_IT_Update ) != RESET )
	 {
		  // If in broadcast mode and the gyros have been calibrated, transmit data packet
		  
		  if( (gConfig.broadcast_enabled == MODE_BROADCAST) && gGyrosCalibrated )
  2a:	f240 0300 	movw	r3, #0	; 0x0
  2e:	f2c0 0300 	movt	r3, #0	; 0x0
  32:	881a      	ldrh	r2, [r3, #0]
  34:	2a00      	cmp	r2, #0
  36:	d0f2      	beq.n	1e <TIM2_IRQHandler+0x1e>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:251
		  {
				// If the TX Packet Buffer is being used, then do not send data this time.  This is required since
				// the timer interrupt may have occured when the IMU was responding to a packet received over the
				// UART.
				if( TXPacketBufferReady )
  38:	f240 0400 	movw	r4, #0	; 0x0
  3c:	f2c0 0400 	movt	r4, #0	; 0x0
  40:	7823      	ldrb	r3, [r4, #0]
  42:	2b00      	cmp	r3, #0
  44:	d0eb      	beq.n	1e <TIM2_IRQHandler+0x1e>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:253
				{
					 TXPacketBufferReady = 0;
  46:	2300      	movs	r3, #0
  48:	7023      	strb	r3, [r4, #0]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:254
					 SendDataPacket( );
  4a:	f7ff fffe 	bl	0 <SendDataPacket>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:255
					 TXPacketBufferReady = 1;
  4e:	7025      	strb	r5, [r4, #0]
  50:	e7e5      	b.n	1e <SendDataPacket+0x1e>
  52:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.DMA1_Channel1_IRQHandler:

00000000 <DMA1_Channel1_IRQHandler>:
DMA1_Channel1_IRQHandler():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:209
						 stores ADC data from the sensors, and is divided into two halves:
						 a "ping" buffer, and a "pong" buffer.  While one buffer is
						 filled, the data in the other is processed by the core.
*******************************************************************************/
void DMA1_Channel1_IRQHandler( void )
{
   0:	b510      	push	{r4, lr}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:212

    // Interrupt service handler for half-transfer
    if( DMA_GetITStatus( DMA1_IT_HT1 ) != RESET )
   2:	2004      	movs	r0, #4
   4:	f7ff fffe 	bl	0 <DMA_GetITStatus>
   8:	b968      	cbnz	r0, 26 <DMA1_Channel1_IRQHandler+0x26>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:220
		      
        DMA_ClearFlag( DMA1_FLAG_HT1 );
    }

    // Interrupt service handler for full transfer
    if( DMA_GetITStatus( DMA1_IT_TC1 ) != RESET )
   a:	2002      	movs	r0, #2
   c:	f7ff fffe 	bl	0 <DMA_GetITStatus>
  10:	b140      	cbz	r0, 14 <gPongBufferReady+0x14>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:222
    {
		  gPongBufferReady = 1;
  12:	f240 0300 	movw	r3, #0	; 0x0
  16:	f2c0 0300 	movt	r3, #0	; 0x0
  1a:	2201      	movs	r2, #1
  1c:	601a      	str	r2, [r3, #0]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:224
        
        DMA_ClearFlag( DMA1_FLAG_TC1 );
  1e:	2002      	movs	r0, #2
  20:	f7ff fffe 	bl	0 <DMA_ClearFlag>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:227
    }

}
  24:	bd10      	pop	{r4, pc}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:214
{

    // Interrupt service handler for half-transfer
    if( DMA_GetITStatus( DMA1_IT_HT1 ) != RESET )
    {
		  gPingBufferReady = 1;
  26:	f240 0300 	movw	r3, #0	; 0x0
  2a:	f2c0 0300 	movt	r3, #0	; 0x0
  2e:	2201      	movs	r2, #1
  30:	601a      	str	r2, [r3, #0]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:216
		      
        DMA_ClearFlag( DMA1_FLAG_HT1 );
  32:	2004      	movs	r0, #4
  34:	f7ff fffe 	bl	0 <DMA_ClearFlag>
  38:	e7e7      	b.n	a <DMA_ClearFlag+0xa>
  3a:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.main:

00000000 <main>:
main():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:44
* Output         : None
* Return         : None
* Description    : Entry point for CHR-6dm firmware
*******************************************************************************/
int main(void)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:54
	 
	 uint8_t HMC_status;
	 
	 int32_t states_initialized = 0;
	 	 
	 gSensorData.new_accel_data = 0;
   4:	f240 0700 	movw	r7, #0	; 0x0
   8:	f04f 0300 	mov.w	r3, #0	; 0x0
   c:	f2c0 0700 	movt	r7, #0	; 0x0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:57
	 gSensorData.new_mag_data = 0;
	 
	 gGyrosCalibrated = 0;
  10:	f240 0800 	movw	r8, #0	; 0x0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:54
	 
	 uint8_t HMC_status;
	 
	 int32_t states_initialized = 0;
	 	 
	 gSensorData.new_accel_data = 0;
  14:	81bb      	strh	r3, [r7, #12]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:55
	 gSensorData.new_mag_data = 0;
  16:	82bb      	strh	r3, [r7, #20]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:44
* Output         : None
* Return         : None
* Description    : Entry point for CHR-6dm firmware
*******************************************************************************/
int main(void)
{
  18:	b085      	sub	sp, #20
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:57
	 int32_t states_initialized = 0;
	 	 
	 gSensorData.new_accel_data = 0;
	 gSensorData.new_mag_data = 0;
	 
	 gGyrosCalibrated = 0;
  1a:	f2c0 0800 	movt	r8, #0	; 0x0
  1e:	f8a8 3000 	strh.w	r3, [r8]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:60
	 
	 // Initialize the IMU clocks, ADC, DMA controller, GPIO pins, etc.
	 Initialize_IMU();
  22:	f7ff fffe 	bl	0 <Initialize_IMU>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:63
	 
	 // Fill gConfig structure from flash, or use default values if flash has not been initialized.
    GetConfiguration();
  26:	f7ff fffe 	bl	0 <GetConfiguration>
  2a:	2300      	movs	r3, #0
  2c:	f240 0200 	movw	r2, #0	; 0x0
  30:	f2c0 0200 	movt	r2, #0	; 0x0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:68
 
	 // Clear I2C RX buffer
	 for( i=0; i < I2C_RX_BUFSIZE; i++ )
	 {
		  i2cRxBuf[i] = 0;
  34:	4619      	mov	r1, r3
  36:	54d1      	strb	r1, [r2, r3]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:66
	 
	 // Fill gConfig structure from flash, or use default values if flash has not been initialized.
    GetConfiguration();
 
	 // Clear I2C RX buffer
	 for( i=0; i < I2C_RX_BUFSIZE; i++ )
  38:	3301      	adds	r3, #1
  3a:	2b0a      	cmp	r3, #10
  3c:	d1fb      	bne.n	36 <main+0x36>
DelayMs():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:400
	 uint32_t iterations;
	 uint32_t index;
	 
	 iterations = delay*5656;
	 
	 for( index = 0; index < iterations; index++ )
  3e:	f248 5380 	movw	r3, #34176	; 0x8580
main():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:66
	 
	 // Fill gConfig structure from flash, or use default values if flash has not been initialized.
    GetConfiguration();
 
	 // Clear I2C RX buffer
	 for( i=0; i < I2C_RX_BUFSIZE; i++ )
  42:	2200      	movs	r2, #0
DelayMs():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:400
	 uint32_t iterations;
	 uint32_t index;
	 
	 iterations = delay*5656;
	 
	 for( index = 0; index < iterations; index++ )
  44:	f2c0 0322 	movt	r3, #34	; 0x22
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:402
	 {
		  asm volatile("mov r0, r0");
  48:	4600      	mov	r0, r0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:400
	 uint32_t iterations;
	 uint32_t index;
	 
	 iterations = delay*5656;
	 
	 for( index = 0; index < iterations; index++ )
  4a:	3201      	adds	r2, #1
  4c:	429a      	cmp	r2, r3
  4e:	d1fb      	bne.n	48 <main+0x48>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:76
	 // Wait a while for supply voltages to stabilize
	 DelayMs( 400 );
	 
	 // Initialize HMC5843
	 int retries = 0;
	 while(!initializeHMC( &HMC_status ) && (retries < MAX_HMC_INIT_RETRIES) )
  50:	f24a 1460 	movw	r4, #41312	; 0xa160
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:400
	 uint32_t iterations;
	 uint32_t index;
	 
	 iterations = delay*5656;
	 
	 for( index = 0; index < iterations; index++ )
  54:	2500      	movs	r5, #0
  56:	f10d 060f 	add.w	r6, sp, #15	; 0xf
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:76
	 // Wait a while for supply voltages to stabilize
	 DelayMs( 400 );
	 
	 // Initialize HMC5843
	 int retries = 0;
	 while(!initializeHMC( &HMC_status ) && (retries < MAX_HMC_INIT_RETRIES) )
  5a:	f2c0 0408 	movt	r4, #8	; 0x8
main():
  5e:	4630      	mov	r0, r6
  60:	f7ff fffe 	bl	0 <initializeHMC>
  64:	4603      	mov	r3, r0
  66:	b940      	cbnz	r0, 7a <main+0x7a>
  68:	2d0a      	cmp	r5, #10
  6a:	d006      	beq.n	7a <main+0x7a>
DelayMs():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:400
	 uint32_t iterations;
	 uint32_t index;
	 
	 iterations = delay*5656;
	 
	 for( index = 0; index < iterations; index++ )
  6c:	4618      	mov	r0, r3
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:402
	 {
		  asm volatile("mov r0, r0");
  6e:	4600      	mov	r0, r0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:400
	 uint32_t iterations;
	 uint32_t index;
	 
	 iterations = delay*5656;
	 
	 for( index = 0; index < iterations; index++ )
  70:	3001      	adds	r0, #1
  72:	42a0      	cmp	r0, r4
  74:	d1fb      	bne.n	6e <main+0x6e>
main():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:80
	 int retries = 0;
	 while(!initializeHMC( &HMC_status ) && (retries < MAX_HMC_INIT_RETRIES) )
	 {
		  DelayMs( 100 );
		  
		  retries++;
  76:	3501      	adds	r5, #1
  78:	e7f1      	b.n	5e <main+0x5e>
DelayMs():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:400
	 uint32_t iterations;
	 uint32_t index;
	 
	 iterations = delay*5656;
	 
	 for( index = 0; index < iterations; index++ )
  7a:	f24e 4320 	movw	r3, #58400	; 0xe420
main():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:76
	 // Wait a while for supply voltages to stabilize
	 DelayMs( 400 );
	 
	 // Initialize HMC5843
	 int retries = 0;
	 while(!initializeHMC( &HMC_status ) && (retries < MAX_HMC_INIT_RETRIES) )
  7e:	2200      	movs	r2, #0
DelayMs():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:400
	 uint32_t iterations;
	 uint32_t index;
	 
	 iterations = delay*5656;
	 
	 for( index = 0; index < iterations; index++ )
  80:	f2c0 0319 	movt	r3, #25	; 0x19
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:402
	 {
		  asm volatile("mov r0, r0");
  84:	4600      	mov	r0, r0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:400
	 uint32_t iterations;
	 uint32_t index;
	 
	 iterations = delay*5656;
	 
	 for( index = 0; index < iterations; index++ )
  86:	3201      	adds	r2, #1
  88:	429a      	cmp	r2, r3
  8a:	d1fb      	bne.n	84 <main+0x84>
main():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:90
	 // Configure and enable EXTI line for magnetometer.
	 // This is performed outside chr6dm_startup.c because early erroneous interrupts
	 // on the mag. ready line can cause the unit to poll the magnetometer too quickly,
	 // causing synchronization problems.
	 EXTI_InitTypeDef EXTI_InitStructure;
	 EXTI_InitStructure.EXTI_Line = EXTI_Line15;
  8c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:104
//		  USART1_transmit("Failed to initialize HMC\r\n", 26);
	 }
	 
	 // Start "zero gyros" command.  When finished, the global flag gGyrosCalibrated will be set, and
	 // the main execution code will know to start estimating states and transmitting data.
	 if( gConfig.gyro_startup_calibration )
  90:	f240 0400 	movw	r4, #0	; 0x0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:90
	 // Configure and enable EXTI line for magnetometer.
	 // This is performed outside chr6dm_startup.c because early erroneous interrupts
	 // on the mag. ready line can cause the unit to poll the magnetometer too quickly,
	 // causing synchronization problems.
	 EXTI_InitTypeDef EXTI_InitStructure;
	 EXTI_InitStructure.EXTI_Line = EXTI_Line15;
  94:	9301      	str	r3, [sp, #4]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:91
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  96:	2200      	movs	r2, #0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:92
	 EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
  98:	230c      	movs	r3, #12
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:94

    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  9a:	2501      	movs	r5, #1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:95
    EXTI_Init(&EXTI_InitStructure);
  9c:	a801      	add	r0, sp, #4
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:104
//		  USART1_transmit("Failed to initialize HMC\r\n", 26);
	 }
	 
	 // Start "zero gyros" command.  When finished, the global flag gGyrosCalibrated will be set, and
	 // the main execution code will know to start estimating states and transmitting data.
	 if( gConfig.gyro_startup_calibration )
  9e:	f2c0 0400 	movt	r4, #0	; 0x0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:92
	 // on the mag. ready line can cause the unit to poll the magnetometer too quickly,
	 // causing synchronization problems.
	 EXTI_InitTypeDef EXTI_InitStructure;
	 EXTI_InitStructure.EXTI_Line = EXTI_Line15;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	 EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
  a2:	f88d 3009 	strb.w	r3, [sp, #9]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:91
	 // This is performed outside chr6dm_startup.c because early erroneous interrupts
	 // on the mag. ready line can cause the unit to poll the magnetometer too quickly,
	 // causing synchronization problems.
	 EXTI_InitTypeDef EXTI_InitStructure;
	 EXTI_InitStructure.EXTI_Line = EXTI_Line15;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  a6:	f88d 2008 	strb.w	r2, [sp, #8]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:94
	 EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  

    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  aa:	f88d 500a 	strb.w	r5, [sp, #10]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:95
    EXTI_Init(&EXTI_InitStructure);
  ae:	f7ff fffe 	bl	0 <EXTI_Init>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:104
//		  USART1_transmit("Failed to initialize HMC\r\n", 26);
	 }
	 
	 // Start "zero gyros" command.  When finished, the global flag gGyrosCalibrated will be set, and
	 // the main execution code will know to start estimating states and transmitting data.
	 if( gConfig.gyro_startup_calibration )
  b2:	f894 30b7 	ldrb.w	r3, [r4, #183]
  b6:	2b00      	cmp	r3, #0
  b8:	f040 80a0 	bne.w	1fc <main+0x1fc>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:110
	 {
		  StartGyroCalibration();
	 }
	 else
	 {
		  gGyrosCalibrated = 1;		  
  bc:	f8a8 5000 	strh.w	r5, [r8]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:116
	 }
	 
	 // Start ADC1 Software Conversion.  ADC1 and ADC2 are configured to sample simultaneously and to 
	 // use DMA1 to transfer data to memory.

    ADC_SoftwareStartConvCmd(ADC1, ENABLE);
  c0:	f242 4000 	movw	r0, #9216	; 0x2400
  c4:	2101      	movs	r1, #1
  c6:	f2c4 0001 	movt	r0, #16385	; 0x4001
  ca:	f7ff fffe 	bl	0 <ADC_SoftwareStartConvCmd>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:119
 
	 // Start TIM1 if in broadcast mode
	 if( gConfig.broadcast_enabled == MODE_BROADCAST )
  ce:	f894 30b8 	ldrb.w	r3, [r4, #184]
  d2:	f240 0200 	movw	r2, #0	; 0x0
  d6:	2b01      	cmp	r3, #1
  d8:	f2c0 0200 	movt	r2, #0	; 0x0
  dc:	d103      	bne.n	e6 <main+0xe6>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:121
	 {
		  EnableBroadcastMode( gConfig.broadcast_rate );
  de:	f892 00b9 	ldrb.w	r0, [r2, #185]
  e2:	f7ff fffe 	bl	0 <EnableBroadcastMode>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:126
	 }
	 
	 	 
	 // Start timer3 for prediction period tracking
	 TIM_SetCounter(TIM3,0);
  e6:	f240 4000 	movw	r0, #1024	; 0x400
  ea:	f2c4 0000 	movt	r0, #16384	; 0x4000
  ee:	2100      	movs	r1, #0
  f0:	f7ff fffe 	bl	0 <TIM_SetCounter>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:127
	 TIM_Cmd(TIM3, ENABLE);
  f4:	f240 4000 	movw	r0, #1024	; 0x400
  f8:	f2c4 0000 	movt	r0, #16384	; 0x4000
  fc:	2101      	movs	r1, #1
  fe:	f240 0600 	movw	r6, #0	; 0x0
 102:	f240 0500 	movw	r5, #0	; 0x0
 106:	f240 0a00 	movw	sl, #0	; 0x0
 10a:	f240 0900 	movw	r9, #0	; 0x0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:133
	 
	 // Main program loop
    while(1)
    {
		  // Filter new inertial sensor data if available (new_data = 0 if there was no new data ready, 1 otherwise)
		  new_data = process_input_buffers( gADC_Output );
 10e:	f240 0400 	movw	r4, #0	; 0x0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:127
	 }
	 
	 	 
	 // Start timer3 for prediction period tracking
	 TIM_SetCounter(TIM3,0);
	 TIM_Cmd(TIM3, ENABLE);
 112:	f7ff fffe 	bl	0 <TIM_Cmd>
 116:	f2c0 0600 	movt	r6, #0	; 0x0
 11a:	f2c0 0500 	movt	r5, #0	; 0x0
 11e:	f2c0 0a00 	movt	sl, #0	; 0x0
 122:	f2c0 0900 	movt	r9, #0	; 0x0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:133
	 
	 // Main program loop
    while(1)
    {
		  // Filter new inertial sensor data if available (new_data = 0 if there was no new data ready, 1 otherwise)
		  new_data = process_input_buffers( gADC_Output );
 126:	f2c0 0400 	movt	r4, #0	; 0x0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:186
				// If there are no more packets ready for processing, clear the gRXPacketReceived flag.
				// If there is another packet ready, leave the flag set so that the other RX packet will
				// be processed the next time through the main loop.
				if( gRXPacketBufferStart == gRXPacketBufferEnd )
				{
					 gRXPacketReceived = 0;
 12a:	f04f 0b00 	mov.w	fp, #0	; 0x0
 12e:	e004      	b.n	c <HandleUSART1Reception+0xc>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:166
				}
		  
		  }
		  
		  // Handle any new characters received by the UART (piped into memory via DMA)
		  HandleUSART1Reception();
 130:	f7ff fffe 	bl	0 <HandleUSART1Reception>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:169
	  
		  // Check if a packet has been received over the UART.  If so, respond.
		  if( gRXPacketReceived )
 134:	7833      	ldrb	r3, [r6, #0]
 136:	2b00      	cmp	r3, #0
 138:	d13a      	bne.n	1b0 <main+0x1b0>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:133
	 
	 // Main program loop
    while(1)
    {
		  // Filter new inertial sensor data if available (new_data = 0 if there was no new data ready, 1 otherwise)
		  new_data = process_input_buffers( gADC_Output );
 13a:	f240 0000 	movw	r0, #0	; 0x0
 13e:	f2c0 0000 	movt	r0, #0	; 0x0
 142:	f7ff fffe 	bl	0 <process_input_buffers>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:136
		  
		  // If new data is available, make new state estimates
		  if( new_data && gGyrosCalibrated )
 146:	2800      	cmp	r0, #0
 148:	d0f2      	beq.n	130 <main+0x130>
 14a:	f8b8 3000 	ldrh.w	r3, [r8]
 14e:	2b00      	cmp	r3, #0
 150:	d0ee      	beq.n	130 <main+0x130>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:138
		  {
				gSensorData.new_accel_data = 1;
 152:	f04f 0301 	mov.w	r3, #1	; 0x1
 156:	81bb      	strh	r3, [r7, #12]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:141
				
				// Convert to NED coordinate axes
				gSensorData.accel_x = -gADC_Output[0];
 158:	8823      	ldrh	r3, [r4, #0]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:150
				// Convert to NED coordinate axes
				gSensorData.gyro_x = gADC_Output[4];
				gSensorData.gyro_y = gADC_Output[3];
				gSensorData.gyro_z = gADC_Output[5];
				
				EKF_EstimateStates( &gEstimatedStates, &gSensorData );
 15a:	f240 0000 	movw	r0, #0	; 0x0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:141
		  if( new_data && gGyrosCalibrated )
		  {
				gSensorData.new_accel_data = 1;
				
				// Convert to NED coordinate axes
				gSensorData.accel_x = -gADC_Output[0];
 15e:	425b      	negs	r3, r3
 160:	80fb      	strh	r3, [r7, #6]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:142
				gSensorData.accel_y = gADC_Output[1];
 162:	8863      	ldrh	r3, [r4, #2]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:150
				// Convert to NED coordinate axes
				gSensorData.gyro_x = gADC_Output[4];
				gSensorData.gyro_y = gADC_Output[3];
				gSensorData.gyro_z = gADC_Output[5];
				
				EKF_EstimateStates( &gEstimatedStates, &gSensorData );
 164:	f240 0100 	movw	r1, #0	; 0x0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:142
		  {
				gSensorData.new_accel_data = 1;
				
				// Convert to NED coordinate axes
				gSensorData.accel_x = -gADC_Output[0];
				gSensorData.accel_y = gADC_Output[1];
 168:	813b      	strh	r3, [r7, #8]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:143
				gSensorData.accel_z = -gADC_Output[2];
 16a:	88a3      	ldrh	r3, [r4, #4]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:150
				// Convert to NED coordinate axes
				gSensorData.gyro_x = gADC_Output[4];
				gSensorData.gyro_y = gADC_Output[3];
				gSensorData.gyro_z = gADC_Output[5];
				
				EKF_EstimateStates( &gEstimatedStates, &gSensorData );
 16c:	f2c0 0000 	movt	r0, #0	; 0x0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:143
				gSensorData.new_accel_data = 1;
				
				// Convert to NED coordinate axes
				gSensorData.accel_x = -gADC_Output[0];
				gSensorData.accel_y = gADC_Output[1];
				gSensorData.accel_z = -gADC_Output[2];
 170:	425b      	negs	r3, r3
 172:	817b      	strh	r3, [r7, #10]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:146
				
				// Convert to NED coordinate axes
				gSensorData.gyro_x = gADC_Output[4];
 174:	8923      	ldrh	r3, [r4, #8]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:150
				gSensorData.gyro_y = gADC_Output[3];
				gSensorData.gyro_z = gADC_Output[5];
				
				EKF_EstimateStates( &gEstimatedStates, &gSensorData );
 176:	f2c0 0100 	movt	r1, #0	; 0x0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:146
				gSensorData.accel_x = -gADC_Output[0];
				gSensorData.accel_y = gADC_Output[1];
				gSensorData.accel_z = -gADC_Output[2];
				
				// Convert to NED coordinate axes
				gSensorData.gyro_x = gADC_Output[4];
 17a:	803b      	strh	r3, [r7, #0]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:147
				gSensorData.gyro_y = gADC_Output[3];
 17c:	88e3      	ldrh	r3, [r4, #6]
 17e:	807b      	strh	r3, [r7, #2]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:148
				gSensorData.gyro_z = gADC_Output[5];
 180:	8963      	ldrh	r3, [r4, #10]
 182:	80bb      	strh	r3, [r7, #4]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:150
				
				EKF_EstimateStates( &gEstimatedStates, &gSensorData );
 184:	f7ff fffe 	bl	0 <EKF_EstimateStates>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:152
				
				uint8_t output_value = GPIO_ReadInputDataBit( GPIOB, GPIO_Pin_5 );
 188:	f640 4000 	movw	r0, #3072	; 0xc00
 18c:	f2c4 0001 	movt	r0, #16385	; 0x4001
 190:	2120      	movs	r1, #32
 192:	f7ff fffe 	bl	0 <GPIO_ReadInputDataBit>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:154
		  
				if( output_value )
 196:	b348      	cbz	r0, 1ec <main+0x1ec>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:156
				{
					 GPIO_ResetBits( GPIOB, GPIO_Pin_5 );
 198:	f640 4000 	movw	r0, #3072	; 0xc00
 19c:	f2c4 0001 	movt	r0, #16385	; 0x4001
 1a0:	2120      	movs	r1, #32
 1a2:	f7ff fffe 	bl	0 <GPIO_ResetBits>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:166
				}
		  
		  }
		  
		  // Handle any new characters received by the UART (piped into memory via DMA)
		  HandleUSART1Reception();
 1a6:	f7ff fffe 	bl	0 <HandleUSART1Reception>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:169
	  
		  // Check if a packet has been received over the UART.  If so, respond.
		  if( gRXPacketReceived )
 1aa:	7833      	ldrb	r3, [r6, #0]
 1ac:	2b00      	cmp	r3, #0
 1ae:	d0c4      	beq.n	13a <main+0x13a>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:171
		  {
				ProcessPacket( (USARTPacket*)&gRXPacketBuffer[gRXPacketBufferStart] );
 1b0:	782b      	ldrb	r3, [r5, #0]
 1b2:	009a      	lsls	r2, r3, #2
 1b4:	0118      	lsls	r0, r3, #4
 1b6:	1a80      	subs	r0, r0, r2
 1b8:	1ac0      	subs	r0, r0, r3
 1ba:	0080      	lsls	r0, r0, #2
 1bc:	4450      	add	r0, sl
 1be:	f7ff fffe 	bl	0 <ProcessPacket>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:175

				// Increment RX packet buffer pointer.  The RX and TX buffer is circular.  The buffer is
				// empty if the "start" and "end" pointers point to the same location.
				gRXPacketBufferStart++;
 1c2:	782b      	ldrb	r3, [r5, #0]
 1c4:	3301      	adds	r3, #1
 1c6:	b2db      	uxtb	r3, r3
 1c8:	702b      	strb	r3, [r5, #0]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:176
				if( gRXPacketBufferStart >= RX_PACKET_BUFFER_SIZE )
 1ca:	782a      	ldrb	r2, [r5, #0]
 1cc:	2a13      	cmp	r2, #19
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:178
				{
					 gRXPacketBufferStart = 0;
 1ce:	bf82      	ittt	hi
 1d0:	f240 0300 	movwhi	r3, #0	; 0x0
 1d4:	f2c0 0300 	movthi	r3, #0	; 0x0
 1d8:	f883 b000 	strbhi.w	fp, [r3]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:184
				}
				
				// If there are no more packets ready for processing, clear the gRXPacketReceived flag.
				// If there is another packet ready, leave the flag set so that the other RX packet will
				// be processed the next time through the main loop.
				if( gRXPacketBufferStart == gRXPacketBufferEnd )
 1dc:	782a      	ldrb	r2, [r5, #0]
 1de:	f899 3000 	ldrb.w	r3, [r9]
 1e2:	429a      	cmp	r2, r3
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:186
				{
					 gRXPacketReceived = 0;
 1e4:	bf08      	it	eq
 1e6:	f886 b000 	strbeq.w	fp, [r6]
 1ea:	e7a6      	b.n	13a <main+0x13a>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:160
				{
					 GPIO_ResetBits( GPIOB, GPIO_Pin_5 );
				}
				else
				{
					 GPIO_SetBits( GPIOB, GPIO_Pin_5 );
 1ec:	f640 4000 	movw	r0, #3072	; 0xc00
 1f0:	f2c4 0001 	movt	r0, #16385	; 0x4001
 1f4:	2120      	movs	r1, #32
 1f6:	f7ff fffe 	bl	0 <GPIO_SetBits>
 1fa:	e799      	b.n	ffffff36 <StartGyroCalibration+0xffffff36>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/main.c:106
	 
	 // Start "zero gyros" command.  When finished, the global flag gGyrosCalibrated will be set, and
	 // the main execution code will know to start estimating states and transmitting data.
	 if( gConfig.gyro_startup_calibration )
	 {
		  StartGyroCalibration();
 1fc:	f7ff fffe 	bl	0 <StartGyroCalibration>
 200:	e75e      	b.n	c0 <StartGyroCalibration+0xc0>
 202:	46c0      	nop			(mov r8, r8)
