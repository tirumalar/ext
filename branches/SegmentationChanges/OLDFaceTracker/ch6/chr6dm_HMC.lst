
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease\chr6dm_HMC.o:     file format elf32-littlearm
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease\chr6dm_HMC.o

Disassembly of section .text.i2cWaitForEvent:

00000000 <i2cWaitForEvent>:
i2cWaitForEvent():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:311
* Description    : Wrapper function for i2c functionality.  Checks for the specified
						 event I2C_ACK_ATTEMPTS times, and then errors out if the event
						 hasn't occured.
*******************************************************************************/
int i2cWaitForEvent( uint32_t event )
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4605      	mov	r5, r0
   4:	2400      	movs	r4, #0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:318
	 
	 attempts = 0;
	 while(!I2C_CheckEvent(I2C1, event))
	 {
		  attempts++;
		  if( attempts > I2C_ACK_ATTEMPTS )
   6:	f241 3689 	movw	r6, #5001	; 0x1389
   a:	e002      	b.n	12 <i2cWaitForEvent+0x12>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:317
	 int32_t attempts;
	 
	 attempts = 0;
	 while(!I2C_CheckEvent(I2C1, event))
	 {
		  attempts++;
   c:	3401      	adds	r4, #1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:318
		  if( attempts > I2C_ACK_ATTEMPTS )
   e:	42b4      	cmp	r4, r6
  10:	d00b      	beq.n	2a <i2cWaitForEvent+0x2a>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:315
int i2cWaitForEvent( uint32_t event )
{
	 int32_t attempts;
	 
	 attempts = 0;
	 while(!I2C_CheckEvent(I2C1, event))
  12:	f245 4000 	movw	r0, #21504	; 0x5400
  16:	f2c4 0000 	movt	r0, #16384	; 0x4000
  1a:	4629      	mov	r1, r5
  1c:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  20:	4603      	mov	r3, r0
  22:	2800      	cmp	r0, #0
  24:	d0f2      	beq.n	c <I2C_CheckEvent+0xc>
  26:	2001      	movs	r0, #1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:325
				return 0;
		  }		  
	 }
	 
	 return 1;
}
  28:	bd70      	pop	{r4, r5, r6, pc}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:318
	 
	 attempts = 0;
	 while(!I2C_CheckEvent(I2C1, event))
	 {
		  attempts++;
		  if( attempts > I2C_ACK_ATTEMPTS )
  2a:	4618      	mov	r0, r3
  2c:	e7fc      	b.n	28 <I2C_CheckEvent+0x28>
  2e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.i2cRead:

00000000 <i2cRead>:
i2cRead():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:232
* Return         : 1 if success, 0 if fail
* Description    : Writes 'length' bytes from i2cData[] to the i2c address 'addr'
						 This is a blocking function.
*******************************************************************************/
int32_t i2cRead( uint8_t addr, uint8_t* i2cData, uint8_t bytesToRead )
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4605      	mov	r5, r0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:237
	 uint8_t* pBuffer = i2cData;
	 int32_t retries;
	 
	 // Send START condition
	 I2C_GenerateSTART(I2C1, ENABLE);
   6:	f245 4000 	movw	r0, #21504	; 0x5400
   a:	f2c4 0000 	movt	r0, #16384	; 0x4000
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:232
* Return         : 1 if success, 0 if fail
* Description    : Writes 'length' bytes from i2cData[] to the i2c address 'addr'
						 This is a blocking function.
*******************************************************************************/
int32_t i2cRead( uint8_t addr, uint8_t* i2cData, uint8_t bytesToRead )
{
   e:	460f      	mov	r7, r1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:237
	 uint8_t* pBuffer = i2cData;
	 int32_t retries;
	 
	 // Send START condition
	 I2C_GenerateSTART(I2C1, ENABLE);
  10:	2101      	movs	r1, #1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:232
* Return         : 1 if success, 0 if fail
* Description    : Writes 'length' bytes from i2cData[] to the i2c address 'addr'
						 This is a blocking function.
*******************************************************************************/
int32_t i2cRead( uint8_t addr, uint8_t* i2cData, uint8_t bytesToRead )
{
  12:	4616      	mov	r6, r2
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:237
	 uint8_t* pBuffer = i2cData;
	 int32_t retries;
	 
	 // Send START condition
	 I2C_GenerateSTART(I2C1, ENABLE);
  14:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:240

	 // Wait for START condition to transmit
	 if( !i2cWaitForEvent(I2C_EVENT_MASTER_MODE_SELECT) )
  18:	f240 0001 	movw	r0, #1	; 0x1
  1c:	f2c0 0003 	movt	r0, #3	; 0x3
  20:	f7ff fffe 	bl	0 <i2cRead>
  24:	4604      	mov	r4, r0
  26:	2800      	cmp	r0, #0
  28:	d04f      	beq.n	ca <i2cRead+0xca>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:247
		  I2C_GenerateSTOP(I2C1, ENABLE);
		  return 0;
	 }
	 
	 // Send slave address
	 I2C_Send7bitAddress(I2C1, addr, I2C_Direction_Receiver);
  2a:	f245 4000 	movw	r0, #21504	; 0x5400
  2e:	f2c4 0000 	movt	r0, #16384	; 0x4000
  32:	4629      	mov	r1, r5
  34:	2201      	movs	r2, #1
  36:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:250

	 // Wait for ACK
	 if( !i2cWaitForEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) )
  3a:	f240 0002 	movw	r0, #2	; 0x2
  3e:	f2c0 0003 	movt	r0, #3	; 0x3
  42:	f7ff fffe 	bl	0 <i2cRead>
  46:	4604      	mov	r4, r0
  48:	2800      	cmp	r0, #0
  4a:	d03e      	beq.n	ca <i2cRead+0xca>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:258
		  return 0;
	 }
	 
	 // Start receiving data
	 retries = 0;
	 while(bytesToRead  && (retries < MAX_RETRIES))  
  4c:	2e00      	cmp	r6, #0
  4e:	d055      	beq.n	fc <i2cRead+0xfc>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:253

	 // Wait for ACK
	 if( !i2cWaitForEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) )
	 {
		  I2C_GenerateSTOP(I2C1, ENABLE);
		  return 0;
  50:	2400      	movs	r4, #0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:270
				// Send STOP Condition 
				I2C_GenerateSTOP(I2C1, ENABLE);
		  }

		  /* Test on EV7 and clear it */
		  if(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED))  
  52:	f242 780f 	movw	r8, #9999	; 0x270f
  56:	e00a      	b.n	6e <i2cRead+0x6e>
  58:	3401      	adds	r4, #1
  5a:	4544      	cmp	r4, r8
  5c:	bfcc      	ite	gt
  5e:	2300      	movgt	r3, #0
  60:	2301      	movle	r3, #1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:258
		  return 0;
	 }
	 
	 // Start receiving data
	 retries = 0;
	 while(bytesToRead  && (retries < MAX_RETRIES))  
  62:	2e00      	cmp	r6, #0
  64:	bf0c      	ite	eq
  66:	2500      	moveq	r5, #0
  68:	f003 0501 	andne.w	r5, r3, #1	; 0x1
  6c:	b305      	cbz	r5, b0 <i2cRead+0xb0>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:260
	 {
		  if(bytesToRead == 1)
  6e:	2e01      	cmp	r6, #1
  70:	d035      	beq.n	de <i2cRead+0xde>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:270
				// Send STOP Condition 
				I2C_GenerateSTOP(I2C1, ENABLE);
		  }

		  /* Test on EV7 and clear it */
		  if(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED))  
  72:	f245 4000 	movw	r0, #21504	; 0x5400
  76:	f240 0140 	movw	r1, #64	; 0x40
  7a:	f2c4 0000 	movt	r0, #16384	; 0x4000
  7e:	f2c0 0103 	movt	r1, #3	; 0x3
  82:	f7ff fffe 	bl	0 <I2C_CheckEvent>
  86:	2800      	cmp	r0, #0
  88:	d0e6      	beq.n	58 <i2cRead+0x58>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:273
		  {      
				// Read a byte from the EEPROM
				*pBuffer = I2C_ReceiveData(I2C1);
  8a:	f245 4000 	movw	r0, #21504	; 0x5400
  8e:	f2c4 0000 	movt	r0, #16384	; 0x4000
  92:	f7ff fffe 	bl	0 <I2C_ReceiveData>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:279

				/* Point to the next location where the byte read will be saved */
				pBuffer++; 

				/* Decrement the read bytes counter */
				bytesToRead--;
  96:	2401      	movs	r4, #1
  98:	1e73      	subs	r3, r6, #1
  9a:	b2de      	uxtb	r6, r3
  9c:	4623      	mov	r3, r4
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:258
		  return 0;
	 }
	 
	 // Start receiving data
	 retries = 0;
	 while(bytesToRead  && (retries < MAX_RETRIES))  
  9e:	2e00      	cmp	r6, #0
  a0:	bf0c      	ite	eq
  a2:	2500      	moveq	r5, #0
  a4:	f003 0501 	andne.w	r5, r3, #1	; 0x1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:273

		  /* Test on EV7 and clear it */
		  if(I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED))  
		  {      
				// Read a byte from the EEPROM
				*pBuffer = I2C_ReceiveData(I2C1);
  a8:	f807 0b01 	strb.w	r0, [r7], #1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:258
		  return 0;
	 }
	 
	 // Start receiving data
	 retries = 0;
	 while(bytesToRead  && (retries < MAX_RETRIES))  
  ac:	2d00      	cmp	r5, #0
  ae:	d1de      	bne.n	6e <i2cRead+0x6e>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:287
		  }
		  
		  retries++;
	 }
	 
	 if( retries >= MAX_RETRIES )
  b0:	f242 730f 	movw	r3, #9999	; 0x270f
  b4:	429c      	cmp	r4, r3
  b6:	dd21      	ble.n	fc <i2cRead+0xfc>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:289
	 {
		  I2C_GenerateSTOP(I2C1, ENABLE);
  b8:	f245 4000 	movw	r0, #21504	; 0x5400
  bc:	f2c4 0000 	movt	r0, #16384	; 0x4000
  c0:	2101      	movs	r1, #1
  c2:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
  c6:	4628      	mov	r0, r5
  c8:	e007      	b.n	da <i2cRead+0xda>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:252
	 I2C_Send7bitAddress(I2C1, addr, I2C_Direction_Receiver);

	 // Wait for ACK
	 if( !i2cWaitForEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) )
	 {
		  I2C_GenerateSTOP(I2C1, ENABLE);
  ca:	f245 4000 	movw	r0, #21504	; 0x5400
  ce:	f2c4 0000 	movt	r0, #16384	; 0x4000
  d2:	2101      	movs	r1, #1
  d4:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
  d8:	4620      	mov	r0, r4
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:298
	 
	 /* Enable Acknowledgement to be ready for another reception */
	 I2C_AcknowledgeConfig(I2C1, ENABLE);
	 
	 return 1;
}
  da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:263
	 while(bytesToRead  && (retries < MAX_RETRIES))  
	 {
		  if(bytesToRead == 1)
		  {
				// Disable Acknowledgement
				I2C_AcknowledgeConfig(I2C1, DISABLE);
  de:	f245 4000 	movw	r0, #21504	; 0x5400
  e2:	2100      	movs	r1, #0
  e4:	f2c4 0000 	movt	r0, #16384	; 0x4000
  e8:	f7ff fffe 	bl	0 <I2C_AcknowledgeConfig>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:266

				// Send STOP Condition 
				I2C_GenerateSTOP(I2C1, ENABLE);
  ec:	f245 4000 	movw	r0, #21504	; 0x5400
  f0:	f2c4 0000 	movt	r0, #16384	; 0x4000
  f4:	4631      	mov	r1, r6
  f6:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
  fa:	e7ba      	b.n	72 <i2cRead+0x72>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:295
		  return 0;
	 }
	 
	 
	 /* Enable Acknowledgement to be ready for another reception */
	 I2C_AcknowledgeConfig(I2C1, ENABLE);
  fc:	f245 4000 	movw	r0, #21504	; 0x5400
 100:	f2c4 0000 	movt	r0, #16384	; 0x4000
 104:	2101      	movs	r1, #1
 106:	f7ff fffe 	bl	0 <I2C_AcknowledgeConfig>
 10a:	2001      	movs	r0, #1
 10c:	e7e5      	b.n	da <I2C_AcknowledgeConfig+0xda>
 10e:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.getHMCData:

00000000 <getHMCData>:
getHMCData():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:150
						 of the HMC5843, while the last byte is the HMC status register.
						 This function call assumes that the internal register address
						 pointer of the HMC is set to register 0x03.
*******************************************************************************/
int32_t getHMCData( uint8_t* i2cBuf )
{
   0:	b510      	push	{r4, lr}
   2:	4601      	mov	r1, r0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:156
	 int32_t returnval;
	 char statusBuffer[1];
	 
	 
	 // Get data from device
	 returnval = i2cRead( MAG_SLAVE_ADDRESS7, i2cBuf, 7 );
   4:	2207      	movs	r2, #7
   6:	203c      	movs	r0, #60
   8:	f7ff fffe 	bl	0 <getHMCData>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:158

	 if( !returnval )
   c:	4604      	mov	r4, r0
   e:	b108      	cbz	r0, 14 <getHMCData+0x14>
  10:	2001      	movs	r0, #1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:167
	 }
	 else
	 {
		  return 1;
	 }
}
  12:	bd10      	pop	{r4, pc}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:160
	 // Get data from device
	 returnval = i2cRead( MAG_SLAVE_ADDRESS7, i2cBuf, 7 );

	 if( !returnval )
	 {
		  I2C_GenerateSTOP(I2C1, ENABLE);
  14:	f245 4000 	movw	r0, #21504	; 0x5400
  18:	f2c4 0000 	movt	r0, #16384	; 0x4000
  1c:	2101      	movs	r1, #1
  1e:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
  22:	4620      	mov	r0, r4
  24:	e7f5      	b.n	12 <I2C_GenerateSTOP+0x12>
  26:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.i2cBufWrite:

00000000 <i2cBufWrite>:
i2cBufWrite():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:179
* Return         : 1 if success, 0 if fail
* Description    : Writes 'length' bytes from i2cData[] to the i2c address 'addr'
						 This is a blocking function.
*******************************************************************************/
int32_t i2cBufWrite( uint8_t addr, uint8_t* i2cData, uint8_t length )
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4605      	mov	r5, r0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:183
	 int32_t index;
	 	 
	 // Send START condition
	 I2C_GenerateSTART(I2C1, ENABLE);
   6:	f245 4000 	movw	r0, #21504	; 0x5400
   a:	f2c4 0000 	movt	r0, #16384	; 0x4000
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:179
* Return         : 1 if success, 0 if fail
* Description    : Writes 'length' bytes from i2cData[] to the i2c address 'addr'
						 This is a blocking function.
*******************************************************************************/
int32_t i2cBufWrite( uint8_t addr, uint8_t* i2cData, uint8_t length )
{
   e:	460f      	mov	r7, r1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:183
	 int32_t index;
	 	 
	 // Send START condition
	 I2C_GenerateSTART(I2C1, ENABLE);
  10:	2101      	movs	r1, #1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:179
* Return         : 1 if success, 0 if fail
* Description    : Writes 'length' bytes from i2cData[] to the i2c address 'addr'
						 This is a blocking function.
*******************************************************************************/
int32_t i2cBufWrite( uint8_t addr, uint8_t* i2cData, uint8_t length )
{
  12:	4616      	mov	r6, r2
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:183
	 int32_t index;
	 	 
	 // Send START condition
	 I2C_GenerateSTART(I2C1, ENABLE);
  14:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:186

	 // Wait for START condition to transmit
	 if( !i2cWaitForEvent(I2C_EVENT_MASTER_MODE_SELECT) )
  18:	f240 0001 	movw	r0, #1	; 0x1
  1c:	f2c0 0003 	movt	r0, #3	; 0x3
  20:	f7ff fffe 	bl	0 <i2cBufWrite>
  24:	4604      	mov	r4, r0
  26:	b378      	cbz	r0, 88 <i2cBufWrite+0x88>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:193
		  I2C_GenerateSTOP(I2C1, ENABLE);
		  return 0;
	 }
	 
	 // Send slave address
	 I2C_Send7bitAddress(I2C1, addr, I2C_Direction_Transmitter);
  28:	f245 4000 	movw	r0, #21504	; 0x5400
  2c:	f2c4 0000 	movt	r0, #16384	; 0x4000
  30:	4629      	mov	r1, r5
  32:	2200      	movs	r2, #0
  34:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:196

	 // Wait for ACK
	 if( !i2cWaitForEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) )
  38:	f240 0082 	movw	r0, #130	; 0x82
  3c:	f2c0 0007 	movt	r0, #7	; 0x7
  40:	f7ff fffe 	bl	0 <i2cBufWrite>
  44:	4604      	mov	r4, r0
  46:	b1f8      	cbz	r0, 88 <i2cBufWrite+0x88>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:203
		  I2C_GenerateSTOP(I2C1, ENABLE);
		  return 0;
	 }

	 // Start transmitting data
	 for( index = 0; index < length; index++ )
  48:	2e00      	cmp	r6, #0
  4a:	d027      	beq.n	9c <i2cBufWrite+0x9c>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:199

	 // Wait for ACK
	 if( !i2cWaitForEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) )
	 {
		  I2C_GenerateSTOP(I2C1, ENABLE);
		  return 0;
  4c:	2400      	movs	r4, #0
  4e:	e002      	b.n	56 <i2cBufWrite+0x56>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:203
	 }

	 // Start transmitting data
	 for( index = 0; index < length; index++ )
  50:	3401      	adds	r4, #1
  52:	42b4      	cmp	r4, r6
  54:	da22      	bge.n	9c <i2cBufWrite+0x9c>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:206
	 {
		  // Send byte
		  I2C_SendData(I2C1, i2cData[index]);
  56:	f245 4000 	movw	r0, #21504	; 0x5400
  5a:	f2c4 0000 	movt	r0, #16384	; 0x4000
  5e:	5d39      	ldrb	r1, [r7, r4]
  60:	f7ff fffe 	bl	0 <I2C_SendData>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:209

		  // Wait for ACK
		  if( !i2cWaitForEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED) )
  64:	f240 0084 	movw	r0, #132	; 0x84
  68:	f2c0 0007 	movt	r0, #7	; 0x7
  6c:	f7ff fffe 	bl	0 <i2cBufWrite>
  70:	4605      	mov	r5, r0
  72:	2800      	cmp	r0, #0
  74:	d1ec      	bne.n	50 <i2cBufWrite+0x50>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:211
		  {
				I2C_GenerateSTOP(I2C1, ENABLE);
  76:	f245 4000 	movw	r0, #21504	; 0x5400
  7a:	f2c4 0000 	movt	r0, #16384	; 0x4000
  7e:	2101      	movs	r1, #1
  80:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
  84:	4628      	mov	r0, r5
  86:	e007      	b.n	98 <i2cBufWrite+0x98>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:198
	 I2C_Send7bitAddress(I2C1, addr, I2C_Direction_Transmitter);

	 // Wait for ACK
	 if( !i2cWaitForEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) )
	 {
		  I2C_GenerateSTOP(I2C1, ENABLE);
  88:	f245 4000 	movw	r0, #21504	; 0x5400
  8c:	f2c4 0000 	movt	r0, #16384	; 0x4000
  90:	2101      	movs	r1, #1
  92:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
  96:	4620      	mov	r0, r4
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:220
	 
	 /* Send STOP condition */
	 I2C_GenerateSTOP(I2C1, ENABLE);
	 
	 return 1;
}
  98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:217
				return 0;
		  }
	 }
	 
	 /* Send STOP condition */
	 I2C_GenerateSTOP(I2C1, ENABLE);
  9c:	f245 4000 	movw	r0, #21504	; 0x5400
  a0:	f2c4 0000 	movt	r0, #16384	; 0x4000
  a4:	2101      	movs	r1, #1
  a6:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
  aa:	2001      	movs	r0, #1
  ac:	e7f4      	b.n	98 <I2C_GenerateSTOP+0x98>
  ae:	46c0      	nop			(mov r8, r8)
Disassembly of section .text.initializeHMC:

00000000 <initializeHMC>:
initializeHMC():
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:34
						 HMC_REG1_FAILED => Couldn't set register 1
						 HMC_REG2_FAILED => Couldn't set register 2
						 
*******************************************************************************/
int32_t initializeHMC( uint8_t* status_flag )
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	b086      	sub	sp, #24
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:47
//	 I2C1_Buffer_Tx[1] = 0x04;	// 1 Hz
//	 I2C1_Buffer_Tx[1] = 0x08;	// 2 Hz
//	 I2C1_Buffer_Tx[1] = 0x0C;	// 5 Hz
//	 I2C1_Buffer_Tx[1] = 0x10;	// 10 Hz
	 
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 2 ) )
   6:	f10d 060e 	add.w	r6, sp, #14	; 0xe
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:41
	 uint8_t I2C1_Buffer_Tx[I2C_TX_BUFSIZE];
	 uint8_t I2C1_Buffer_Rx[I2C_RX_BUFSIZE];
	 
	 // Set mag. update frequency to 50 Hz
	 I2C1_Buffer_Tx[0] = 0x00;
	 I2C1_Buffer_Tx[1] = 0x18;		// 50 Hz
   a:	2318      	movs	r3, #24
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:34
						 HMC_REG1_FAILED => Couldn't set register 1
						 HMC_REG2_FAILED => Couldn't set register 2
						 
*******************************************************************************/
int32_t initializeHMC( uint8_t* status_flag )
{
   c:	4605      	mov	r5, r0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:40
	 
	 uint8_t I2C1_Buffer_Tx[I2C_TX_BUFSIZE];
	 uint8_t I2C1_Buffer_Rx[I2C_RX_BUFSIZE];
	 
	 // Set mag. update frequency to 50 Hz
	 I2C1_Buffer_Tx[0] = 0x00;
   e:	2700      	movs	r7, #0
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:47
//	 I2C1_Buffer_Tx[1] = 0x04;	// 1 Hz
//	 I2C1_Buffer_Tx[1] = 0x08;	// 2 Hz
//	 I2C1_Buffer_Tx[1] = 0x0C;	// 5 Hz
//	 I2C1_Buffer_Tx[1] = 0x10;	// 10 Hz
	 
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 2 ) )
  10:	203c      	movs	r0, #60
  12:	4631      	mov	r1, r6
  14:	2202      	movs	r2, #2
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:40
	 
	 uint8_t I2C1_Buffer_Tx[I2C_TX_BUFSIZE];
	 uint8_t I2C1_Buffer_Rx[I2C_RX_BUFSIZE];
	 
	 // Set mag. update frequency to 50 Hz
	 I2C1_Buffer_Tx[0] = 0x00;
  16:	f88d 700e 	strb.w	r7, [sp, #14]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:41
	 I2C1_Buffer_Tx[1] = 0x18;		// 50 Hz
  1a:	f88d 300f 	strb.w	r3, [sp, #15]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:47
//	 I2C1_Buffer_Tx[1] = 0x04;	// 1 Hz
//	 I2C1_Buffer_Tx[1] = 0x08;	// 2 Hz
//	 I2C1_Buffer_Tx[1] = 0x0C;	// 5 Hz
//	 I2C1_Buffer_Tx[1] = 0x10;	// 10 Hz
	 
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 2 ) )
  1e:	f7ff fffe 	bl	0 <initializeHMC>
  22:	4604      	mov	r4, r0
  24:	b1f8      	cbz	r0, 66 <initializeHMC+0x66>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:56
		  return 0;
	 }
	 
	 // Read back value of register
	 I2C1_Buffer_Tx[0] = 0x00;
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 1 ) )
  26:	203c      	movs	r0, #60
  28:	4631      	mov	r1, r6
  2a:	2201      	movs	r2, #1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:55
		  I2C_GenerateSTOP(I2C1, ENABLE);
		  return 0;
	 }
	 
	 // Read back value of register
	 I2C1_Buffer_Tx[0] = 0x00;
  2c:	f88d 700e 	strb.w	r7, [sp, #14]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:56
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 1 ) )
  30:	f7ff fffe 	bl	0 <initializeHMC>
  34:	4604      	mov	r4, r0
  36:	b1b0      	cbz	r0, 66 <initializeHMC+0x66>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:63
		  *status_flag = HMC_REG0_FAILED;
		  I2C_GenerateSTOP(I2C1, ENABLE);
		  return 0;
	 }
	 
	 i2cRead( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Rx, 1 );
  38:	f10d 0804 	add.w	r8, sp, #4	; 0x4
  3c:	2201      	movs	r2, #1
  3e:	203c      	movs	r0, #60
  40:	4641      	mov	r1, r8
  42:	f7ff fffe 	bl	0 <initializeHMC>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:65
	 
	 if( I2C1_Buffer_Rx[0] != I2C1_Buffer_Tx[1] )
  46:	f89d 2004 	ldrb.w	r2, [sp, #4]
  4a:	f89d 300f 	ldrb.w	r3, [sp, #15]
  4e:	429a      	cmp	r2, r3
  50:	d015      	beq.n	7e <initializeHMC+0x7e>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:67
	 {
		  *status_flag = HMC_REG0_FAILED;
  52:	2101      	movs	r1, #1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:68
		  I2C_GenerateSTOP(I2C1, ENABLE);
  54:	f245 4000 	movw	r0, #21504	; 0x5400
  58:	f2c4 0000 	movt	r0, #16384	; 0x4000
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:67
	 
	 i2cRead( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Rx, 1 );
	 
	 if( I2C1_Buffer_Rx[0] != I2C1_Buffer_Tx[1] )
	 {
		  *status_flag = HMC_REG0_FAILED;
  5c:	7029      	strb	r1, [r5, #0]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:68
		  I2C_GenerateSTOP(I2C1, ENABLE);
  5e:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
  62:	4638      	mov	r0, r7
  64:	e008      	b.n	78 <initializeHMC+0x78>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:58
	 
	 // Read back value of register
	 I2C1_Buffer_Tx[0] = 0x00;
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 1 ) )
	 {
		  *status_flag = HMC_REG0_FAILED;
  66:	2101      	movs	r1, #1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:59
		  I2C_GenerateSTOP(I2C1, ENABLE);
  68:	f245 4000 	movw	r0, #21504	; 0x5400
  6c:	f2c4 0000 	movt	r0, #16384	; 0x4000
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:58
	 
	 // Read back value of register
	 I2C1_Buffer_Tx[0] = 0x00;
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 1 ) )
	 {
		  *status_flag = HMC_REG0_FAILED;
  70:	7029      	strb	r1, [r5, #0]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:59
		  I2C_GenerateSTOP(I2C1, ENABLE);
  72:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
  76:	4620      	mov	r0, r4
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:136
	 }
	 
	 gHMC_Initialized = 1;
	 
	 return 1;
}
  78:	b006      	add	sp, #24
  7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:76
	 
	 // Set gain setting on mag. sensor
	 I2C1_Buffer_Tx[0] = 0x01;
//	 I2C1_Buffer_Tx[1] = 0x04;		// +/- 3.2 Gauss
//	 I2C1_Buffer_Tx[1] = 0x03;		// +/- 2 Gauss
	 I2C1_Buffer_Tx[1] = 0x02;		// +/- 1.5 Gauss
  7e:	f04f 0902 	mov.w	r9, #2	; 0x2
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:73
		  I2C_GenerateSTOP(I2C1, ENABLE);
		  return 0;
	 }
	 
	 // Set gain setting on mag. sensor
	 I2C1_Buffer_Tx[0] = 0x01;
  82:	f04f 0a01 	mov.w	sl, #1	; 0x1
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:78
//	 I2C1_Buffer_Tx[1] = 0x04;		// +/- 3.2 Gauss
//	 I2C1_Buffer_Tx[1] = 0x03;		// +/- 2 Gauss
	 I2C1_Buffer_Tx[1] = 0x02;		// +/- 1.5 Gauss
	 
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 2 ) )
  86:	203c      	movs	r0, #60
  88:	4631      	mov	r1, r6
  8a:	464a      	mov	r2, r9
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:73
		  I2C_GenerateSTOP(I2C1, ENABLE);
		  return 0;
	 }
	 
	 // Set gain setting on mag. sensor
	 I2C1_Buffer_Tx[0] = 0x01;
  8c:	f88d a00e 	strb.w	sl, [sp, #14]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:76
//	 I2C1_Buffer_Tx[1] = 0x04;		// +/- 3.2 Gauss
//	 I2C1_Buffer_Tx[1] = 0x03;		// +/- 2 Gauss
	 I2C1_Buffer_Tx[1] = 0x02;		// +/- 1.5 Gauss
  90:	f88d 900f 	strb.w	r9, [sp, #15]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:78
	 
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 2 ) )
  94:	f7ff fffe 	bl	0 <initializeHMC>
  98:	4604      	mov	r4, r0
  9a:	b1f0      	cbz	r0, da <initializeHMC+0xda>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:87
		  return 0;
	 }
	 
	 // Read back value of register
	 I2C1_Buffer_Tx[0] = 0x01;
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 1 ) )
  9c:	203c      	movs	r0, #60
  9e:	4631      	mov	r1, r6
  a0:	4652      	mov	r2, sl
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:86
		  I2C_GenerateSTOP(I2C1, ENABLE);
		  return 0;
	 }
	 
	 // Read back value of register
	 I2C1_Buffer_Tx[0] = 0x01;
  a2:	f88d a00e 	strb.w	sl, [sp, #14]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:87
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 1 ) )
  a6:	f7ff fffe 	bl	0 <initializeHMC>
  aa:	4604      	mov	r4, r0
  ac:	b1a8      	cbz	r0, da <initializeHMC+0xda>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:94
		  *status_flag = HMC_REG2_FAILED;
		  I2C_GenerateSTOP(I2C1, ENABLE);
		  return 0;
	 }
	 
	 i2cRead( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Rx, 1 );
  ae:	203c      	movs	r0, #60
  b0:	4652      	mov	r2, sl
  b2:	4641      	mov	r1, r8
  b4:	f7ff fffe 	bl	0 <initializeHMC>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:96
	 
	 if( I2C1_Buffer_Rx[0] != I2C1_Buffer_Tx[1] )
  b8:	f89d 2004 	ldrb.w	r2, [sp, #4]
  bc:	f89d 300f 	ldrb.w	r3, [sp, #15]
  c0:	429a      	cmp	r2, r3
  c2:	d015      	beq.n	f0 <initializeHMC+0xf0>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:128
	 
	 i2cRead( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Rx, 1 );
	 
	 if( I2C1_Buffer_Rx[0] != I2C1_Buffer_Tx[1] )
	 {
		  *status_flag = HMC_REG2_FAILED;
  c4:	2303      	movs	r3, #3
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:129
		  I2C_GenerateSTOP(I2C1, ENABLE);
  c6:	f245 4000 	movw	r0, #21504	; 0x5400
  ca:	f2c4 0000 	movt	r0, #16384	; 0x4000
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:128
	 
	 i2cRead( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Rx, 1 );
	 
	 if( I2C1_Buffer_Rx[0] != I2C1_Buffer_Tx[1] )
	 {
		  *status_flag = HMC_REG2_FAILED;
  ce:	702b      	strb	r3, [r5, #0]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:129
		  I2C_GenerateSTOP(I2C1, ENABLE);
  d0:	4651      	mov	r1, sl
  d2:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
  d6:	4638      	mov	r0, r7
  d8:	e7ce      	b.n	78 <initializeHMC+0x78>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:119
	 
	 // Read back value of register
	 I2C1_Buffer_Tx[0] = 0x02;
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 1 ) )
	 {
		  *status_flag = HMC_REG2_FAILED;
  da:	2303      	movs	r3, #3
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:120
		  I2C_GenerateSTOP(I2C1, ENABLE);
  dc:	f245 4000 	movw	r0, #21504	; 0x5400
  e0:	f2c4 0000 	movt	r0, #16384	; 0x4000
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:119
	 
	 // Read back value of register
	 I2C1_Buffer_Tx[0] = 0x02;
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 1 ) )
	 {
		  *status_flag = HMC_REG2_FAILED;
  e4:	702b      	strb	r3, [r5, #0]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:120
		  I2C_GenerateSTOP(I2C1, ENABLE);
  e6:	4651      	mov	r1, sl
  e8:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
  ec:	4620      	mov	r0, r4
  ee:	e7c3      	b.n	78 <initializeHMC+0x78>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:108
	 
	 // Set magnetometer to run in continuous mode
	 I2C1_Buffer_Tx[0] = 0x02;
	 I2C1_Buffer_Tx[1] = 0x00;
	 
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 2 ) )
  f0:	203c      	movs	r0, #60
  f2:	4631      	mov	r1, r6
  f4:	464a      	mov	r2, r9
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:105
		  return 0;
	 }
	 
	 
	 // Set magnetometer to run in continuous mode
	 I2C1_Buffer_Tx[0] = 0x02;
  f6:	f88d 900e 	strb.w	r9, [sp, #14]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:106
	 I2C1_Buffer_Tx[1] = 0x00;
  fa:	f88d 700f 	strb.w	r7, [sp, #15]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:108
	 
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 2 ) )
  fe:	f7ff fffe 	bl	0 <initializeHMC>
 102:	4604      	mov	r4, r0
 104:	2800      	cmp	r0, #0
 106:	d0e8      	beq.n	da <initializeHMC+0xda>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:117
		  return 0;
	 }
	 
	 // Read back value of register
	 I2C1_Buffer_Tx[0] = 0x02;
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 1 ) )
 108:	203c      	movs	r0, #60
 10a:	4631      	mov	r1, r6
 10c:	4652      	mov	r2, sl
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:116
		  I2C_GenerateSTOP(I2C1, ENABLE);
		  return 0;
	 }
	 
	 // Read back value of register
	 I2C1_Buffer_Tx[0] = 0x02;
 10e:	f88d 900e 	strb.w	r9, [sp, #14]
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:117
	 if( !i2cBufWrite( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Tx, 1 ) )
 112:	f7ff fffe 	bl	0 <initializeHMC>
 116:	4604      	mov	r4, r0
 118:	2800      	cmp	r0, #0
 11a:	d0de      	beq.n	da <initializeHMC+0xda>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:124
		  *status_flag = HMC_REG2_FAILED;
		  I2C_GenerateSTOP(I2C1, ENABLE);
		  return 0;
	 }
	 
	 i2cRead( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Rx, 1 );
 11c:	203c      	movs	r0, #60
 11e:	4652      	mov	r2, sl
 120:	4641      	mov	r1, r8
 122:	f7ff fffe 	bl	0 <initializeHMC>
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:126
	 
	 if( I2C1_Buffer_Rx[0] != I2C1_Buffer_Tx[1] )
 126:	f89d 300f 	ldrb.w	r3, [sp, #15]
 12a:	f89d 2004 	ldrb.w	r2, [sp, #4]
 12e:	429a      	cmp	r2, r3
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:133
		  *status_flag = HMC_REG2_FAILED;
		  I2C_GenerateSTOP(I2C1, ENABLE);
		  return 0;
	 }
	 
	 gHMC_Initialized = 1;
 130:	bf01      	itttt	eq
 132:	f240 0300 	movweq	r3, #0	; 0x0
 136:	f2c0 0300 	movteq	r3, #0	; 0x0
 13a:	f883 a000 	strbeq.w	sl, [r3]
 13e:	4650      	moveq	r0, sl
C:\Users\Caleb\Documents\Ride\projects\CHR6dmRelease/chr6dm_HMC.c:126
		  return 0;
	 }
	 
	 i2cRead( MAG_SLAVE_ADDRESS7, I2C1_Buffer_Rx, 1 );
	 
	 if( I2C1_Buffer_Rx[0] != I2C1_Buffer_Tx[1] )
 140:	d09a      	beq.n	78 <initializeHMC+0x78>
 142:	e7bf      	b.n	c4 <initializeHMC+0xc4>
