/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef NanoDevice_TYPES_H
#define NanoDevice_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace EyelockNano {

struct Error_Code {
  enum type {
    Success = 0,
    User_Already_Present = 1,
    Iris_Not_Mapped_To_User = 2,
    User_Not_Enrolled = 3,
    App_Already_Protected = 4,
    Iris_Already_Present = 5,
    Iris_Mapped_To_Other_Enrolled_User = 6,
    Unknown = 7,
    User_Not_Primary = 8,
    No_device_Found = 9,
    Connection_Already_Exists = 10,
    Connection_Refused = 11,
    Invalid_Input = 12,
    No_Good_Image_Found = 13,
    No_Eye_Found = 14,
    No_Image_Found = 15,
    No_Match_Found = 16,
    Device_Offline = 17,
    Tampered = 18,
    Not_Tampered = 19,
    Device_Has_Better_Version = 20,
    Integrity_Check_Failed = 21,
    File_Not_Accessible = 22,
    Failure = 23,
    Invalid_Record_Id = 24,
    Not_Supported = 25,
    No_Records_Found = 26,
    No_Logs_Found = 27
  };
};

extern const std::map<int, const char*> _Error_Code_VALUES_TO_NAMES;

struct ActivityType {
  enum type {
    INFO = 1,
    WARN = 2,
    ERR = 3
  };
};

extern const std::map<int, const char*> _ActivityType_VALUES_TO_NAMES;

struct UpdateType {
  enum type {
    APP = 0,
    UNIFIED = 1,
    OS = 2,
    FW = 3
  };
};

extern const std::map<int, const char*> _UpdateType_VALUES_TO_NAMES;

struct ELKNS_RestartTypes {
  enum type {
    REBOOT_DEVICE = 0,
    REBOOT_EYELOCK = 1
  };
};

extern const std::map<int, const char*> _ELKNS_RestartTypes_VALUES_TO_NAMES;

struct ELKNS_EventTypes {
  enum type {
    DEVICE_TAMPERED = 0,
    PERSON_MATCHED = 1,
    DEVICE_DISCONNECTED = 2
  };
};

extern const std::map<int, const char*> _ELKNS_EventTypes_VALUES_TO_NAMES;

struct ACD_Type {
  enum type {
    WIEGAND = 0,
    F2F = 1,
    RELAY = 2,
    PAC = 3,
    NONE = 4
  };
};

extern const std::map<int, const char*> _ACD_Type_VALUES_TO_NAMES;

struct ELKNS_ImageFormats {
  enum type {
    CENTER_CROPPED_IMAGES = 0,
    CENTERED_IMAGES = 1,
    EYE_CROPPED_IMAGES = 2
  };
};

extern const std::map<int, const char*> _ELKNS_ImageFormats_VALUES_TO_NAMES;

struct ELKNS_RelayTypes {
  enum type {
    GRANT_RELAY = 0,
    DENY_RELAY = 1
  };
};

extern const std::map<int, const char*> _ELKNS_RelayTypes_VALUES_TO_NAMES;

typedef std::string GUID;

typedef struct _Iris__isset {
  _Iris__isset() : m_iris_code(false), m_iris_mask(false), m_iris_type(false) {}
  bool m_iris_code;
  bool m_iris_mask;
  bool m_iris_type;
} _Iris__isset;

class Iris {
 public:

  static const char* ascii_fingerprint; // = "343DA57F446177400B333DC49B037B0C";
  static const uint8_t binary_fingerprint[16]; // = {0x34,0x3D,0xA5,0x7F,0x44,0x61,0x77,0x40,0x0B,0x33,0x3D,0xC4,0x9B,0x03,0x7B,0x0C};

  Iris() : m_iris_code(), m_iris_mask(), m_iris_type(0) {
  }

  virtual ~Iris() throw() {}

  std::string m_iris_code;
  std::string m_iris_mask;
  int32_t m_iris_type;

  _Iris__isset __isset;

  void __set_m_iris_code(const std::string& val) {
    m_iris_code = val;
  }

  void __set_m_iris_mask(const std::string& val) {
    m_iris_mask = val;
  }

  void __set_m_iris_type(const int32_t val) {
    m_iris_type = val;
  }

  bool operator == (const Iris & rhs) const
  {
    if (!(m_iris_code == rhs.m_iris_code))
      return false;
    if (!(m_iris_mask == rhs.m_iris_mask))
      return false;
    if (!(m_iris_type == rhs.m_iris_type))
      return false;
    return true;
  }
  bool operator != (const Iris &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Iris & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Iris &a, Iris &b);

typedef struct _ActivityLog__isset {
  _ActivityLog__isset() : Log_id(false), email(false), m_host_machine(false), m_Act_type(false), m_Act_Desc(false), m_timeStamp(false) {}
  bool Log_id;
  bool email;
  bool m_host_machine;
  bool m_Act_type;
  bool m_Act_Desc;
  bool m_timeStamp;
} _ActivityLog__isset;

class ActivityLog {
 public:

  static const char* ascii_fingerprint; // = "59BAC27122966B3FA058EFE417BDA97C";
  static const uint8_t binary_fingerprint[16]; // = {0x59,0xBA,0xC2,0x71,0x22,0x96,0x6B,0x3F,0xA0,0x58,0xEF,0xE4,0x17,0xBD,0xA9,0x7C};

  ActivityLog() : Log_id(0), email(), m_host_machine(), m_Act_type(), m_Act_Desc(), m_timeStamp() {
  }

  virtual ~ActivityLog() throw() {}

  int32_t Log_id;
  std::string email;
  std::string m_host_machine;
  std::string m_Act_type;
  std::string m_Act_Desc;
  std::string m_timeStamp;

  _ActivityLog__isset __isset;

  void __set_Log_id(const int32_t val) {
    Log_id = val;
  }

  void __set_email(const std::string& val) {
    email = val;
  }

  void __set_m_host_machine(const std::string& val) {
    m_host_machine = val;
  }

  void __set_m_Act_type(const std::string& val) {
    m_Act_type = val;
  }

  void __set_m_Act_Desc(const std::string& val) {
    m_Act_Desc = val;
  }

  void __set_m_timeStamp(const std::string& val) {
    m_timeStamp = val;
  }

  bool operator == (const ActivityLog & rhs) const
  {
    if (!(Log_id == rhs.Log_id))
      return false;
    if (!(email == rhs.email))
      return false;
    if (!(m_host_machine == rhs.m_host_machine))
      return false;
    if (!(m_Act_type == rhs.m_Act_type))
      return false;
    if (!(m_Act_Desc == rhs.m_Act_Desc))
      return false;
    if (!(m_timeStamp == rhs.m_timeStamp))
      return false;
    return true;
  }
  bool operator != (const ActivityLog &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ActivityLog & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ActivityLog &a, ActivityLog &b);

typedef struct _EyelockNanoDeviceException__isset {
  _EyelockNanoDeviceException__isset() : custom_error(false), what(false), why(false) {}
  bool custom_error;
  bool what;
  bool why;
} _EyelockNanoDeviceException__isset;

class EyelockNanoDeviceException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "D3BA2D33C1BA9DD4F2FDDA18F1640BC8";
  static const uint8_t binary_fingerprint[16]; // = {0xD3,0xBA,0x2D,0x33,0xC1,0xBA,0x9D,0xD4,0xF2,0xFD,0xDA,0x18,0xF1,0x64,0x0B,0xC8};

  EyelockNanoDeviceException() : custom_error((Error_Code::type)0), what(0), why() {
  }

  virtual ~EyelockNanoDeviceException() throw() {}

  Error_Code::type custom_error;
  int32_t what;
  std::string why;

  _EyelockNanoDeviceException__isset __isset;

  void __set_custom_error(const Error_Code::type val) {
    custom_error = val;
  }

  void __set_what(const int32_t val) {
    what = val;
  }

  void __set_why(const std::string& val) {
    why = val;
  }

  bool operator == (const EyelockNanoDeviceException & rhs) const
  {
    if (!(custom_error == rhs.custom_error))
      return false;
    if (!(what == rhs.what))
      return false;
    if (!(why == rhs.why))
      return false;
    return true;
  }
  bool operator != (const EyelockNanoDeviceException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EyelockNanoDeviceException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(EyelockNanoDeviceException &a, EyelockNanoDeviceException &b);

typedef struct _GetIntReturn__isset {
  _GetIntReturn__isset() : status(false), value(false) {}
  bool status;
  bool value;
} _GetIntReturn__isset;

class GetIntReturn {
 public:

  static const char* ascii_fingerprint; // = "9C2A05F173B50306037BDE9AE30E1B99";
  static const uint8_t binary_fingerprint[16]; // = {0x9C,0x2A,0x05,0xF1,0x73,0xB5,0x03,0x06,0x03,0x7B,0xDE,0x9A,0xE3,0x0E,0x1B,0x99};

  GetIntReturn() : status(0), value(0) {
  }

  virtual ~GetIntReturn() throw() {}

  int32_t status;
  int64_t value;

  _GetIntReturn__isset __isset;

  void __set_status(const int32_t val) {
    status = val;
  }

  void __set_value(const int64_t val) {
    value = val;
  }

  bool operator == (const GetIntReturn & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const GetIntReturn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetIntReturn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(GetIntReturn &a, GetIntReturn &b);

typedef struct _GetDoubleReturn__isset {
  _GetDoubleReturn__isset() : status(false), value(false) {}
  bool status;
  bool value;
} _GetDoubleReturn__isset;

class GetDoubleReturn {
 public:

  static const char* ascii_fingerprint; // = "0B663F1913C9C6F43150B524A8B76386";
  static const uint8_t binary_fingerprint[16]; // = {0x0B,0x66,0x3F,0x19,0x13,0xC9,0xC6,0xF4,0x31,0x50,0xB5,0x24,0xA8,0xB7,0x63,0x86};

  GetDoubleReturn() : status(0), value(0) {
  }

  virtual ~GetDoubleReturn() throw() {}

  int32_t status;
  double value;

  _GetDoubleReturn__isset __isset;

  void __set_status(const int32_t val) {
    status = val;
  }

  void __set_value(const double val) {
    value = val;
  }

  bool operator == (const GetDoubleReturn & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const GetDoubleReturn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetDoubleReturn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(GetDoubleReturn &a, GetDoubleReturn &b);

typedef struct _GetBoolReturn__isset {
  _GetBoolReturn__isset() : status(false), value(false) {}
  bool status;
  bool value;
} _GetBoolReturn__isset;

class GetBoolReturn {
 public:

  static const char* ascii_fingerprint; // = "4DC0C1A1F380340B40244ADC7FB0BA60";
  static const uint8_t binary_fingerprint[16]; // = {0x4D,0xC0,0xC1,0xA1,0xF3,0x80,0x34,0x0B,0x40,0x24,0x4A,0xDC,0x7F,0xB0,0xBA,0x60};

  GetBoolReturn() : status(0), value(0) {
  }

  virtual ~GetBoolReturn() throw() {}

  int32_t status;
  bool value;

  _GetBoolReturn__isset __isset;

  void __set_status(const int32_t val) {
    status = val;
  }

  void __set_value(const bool val) {
    value = val;
  }

  bool operator == (const GetBoolReturn & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const GetBoolReturn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetBoolReturn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(GetBoolReturn &a, GetBoolReturn &b);

typedef struct _GetStrReturn__isset {
  _GetStrReturn__isset() : status(false), value(false) {}
  bool status;
  bool value;
} _GetStrReturn__isset;

class GetStrReturn {
 public:

  static const char* ascii_fingerprint; // = "3F5FC93B338687BC7235B1AB103F47B3";
  static const uint8_t binary_fingerprint[16]; // = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

  GetStrReturn() : status(0), value() {
  }

  virtual ~GetStrReturn() throw() {}

  int32_t status;
  std::string value;

  _GetStrReturn__isset __isset;

  void __set_status(const int32_t val) {
    status = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const GetStrReturn & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const GetStrReturn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GetStrReturn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(GetStrReturn &a, GetStrReturn &b);

} // namespace

#endif
