/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "NanoDevice_types.h"

#include <algorithm>

namespace EyelockNano {

int _kError_CodeValues[] = {
  Error_Code::Success,
  Error_Code::User_Already_Present,
  Error_Code::Iris_Not_Mapped_To_User,
  Error_Code::User_Not_Enrolled,
  Error_Code::App_Already_Protected,
  Error_Code::Iris_Already_Present,
  Error_Code::Iris_Mapped_To_Other_Enrolled_User,
  Error_Code::Unknown,
  Error_Code::User_Not_Primary,
  Error_Code::No_device_Found,
  Error_Code::Connection_Already_Exists,
  Error_Code::Connection_Refused,
  Error_Code::Invalid_Input,
  Error_Code::No_Good_Image_Found,
  Error_Code::No_Eye_Found,
  Error_Code::No_Image_Found,
  Error_Code::No_Match_Found,
  Error_Code::Device_Offline,
  Error_Code::Tampered,
  Error_Code::Not_Tampered,
  Error_Code::Device_Has_Better_Version,
  Error_Code::Integrity_Check_Failed,
  Error_Code::File_Not_Accessible,
  Error_Code::Failure,
  Error_Code::Invalid_Record_Id,
  Error_Code::Not_Supported,
  Error_Code::No_Records_Found,
  Error_Code::No_Logs_Found
};
const char* _kError_CodeNames[] = {
  "Success",
  "User_Already_Present",
  "Iris_Not_Mapped_To_User",
  "User_Not_Enrolled",
  "App_Already_Protected",
  "Iris_Already_Present",
  "Iris_Mapped_To_Other_Enrolled_User",
  "Unknown",
  "User_Not_Primary",
  "No_device_Found",
  "Connection_Already_Exists",
  "Connection_Refused",
  "Invalid_Input",
  "No_Good_Image_Found",
  "No_Eye_Found",
  "No_Image_Found",
  "No_Match_Found",
  "Device_Offline",
  "Tampered",
  "Not_Tampered",
  "Device_Has_Better_Version",
  "Integrity_Check_Failed",
  "File_Not_Accessible",
  "Failure",
  "Invalid_Record_Id",
  "Not_Supported",
  "No_Records_Found",
  "No_Logs_Found"
};
const std::map<int, const char*> _Error_Code_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(28, _kError_CodeValues, _kError_CodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kActivityTypeValues[] = {
  ActivityType::INFO,
  ActivityType::WARN,
  ActivityType::ERR
};
const char* _kActivityTypeNames[] = {
  "INFO",
  "WARN",
  "ERR"
};
const std::map<int, const char*> _ActivityType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kActivityTypeValues, _kActivityTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kUpdateTypeValues[] = {
  UpdateType::APP,
  UpdateType::UNIFIED,
  UpdateType::OS,
  UpdateType::FW
};
const char* _kUpdateTypeNames[] = {
  "APP",
  "UNIFIED",
  "OS",
  "FW"
};
const std::map<int, const char*> _UpdateType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kUpdateTypeValues, _kUpdateTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kELKNS_RestartTypesValues[] = {
  ELKNS_RestartTypes::REBOOT_DEVICE,
  ELKNS_RestartTypes::REBOOT_EYELOCK
};
const char* _kELKNS_RestartTypesNames[] = {
  "REBOOT_DEVICE",
  "REBOOT_EYELOCK"
};
const std::map<int, const char*> _ELKNS_RestartTypes_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kELKNS_RestartTypesValues, _kELKNS_RestartTypesNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kELKNS_EventTypesValues[] = {
  ELKNS_EventTypes::DEVICE_TAMPERED,
  ELKNS_EventTypes::PERSON_MATCHED,
  ELKNS_EventTypes::DEVICE_DISCONNECTED
};
const char* _kELKNS_EventTypesNames[] = {
  "DEVICE_TAMPERED",
  "PERSON_MATCHED",
  "DEVICE_DISCONNECTED"
};
const std::map<int, const char*> _ELKNS_EventTypes_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kELKNS_EventTypesValues, _kELKNS_EventTypesNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kACD_TypeValues[] = {
  ACD_Type::WIEGAND,
  ACD_Type::F2F,
  ACD_Type::RELAY,
  ACD_Type::PAC,
  ACD_Type::NONE
};
const char* _kACD_TypeNames[] = {
  "WIEGAND",
  "F2F",
  "RELAY",
  "PAC",
  "NONE"
};
const std::map<int, const char*> _ACD_Type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kACD_TypeValues, _kACD_TypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kELKNS_ImageFormatsValues[] = {
  ELKNS_ImageFormats::CENTER_CROPPED_IMAGES,
  ELKNS_ImageFormats::CENTERED_IMAGES,
  ELKNS_ImageFormats::EYE_CROPPED_IMAGES
};
const char* _kELKNS_ImageFormatsNames[] = {
  "CENTER_CROPPED_IMAGES",
  "CENTERED_IMAGES",
  "EYE_CROPPED_IMAGES"
};
const std::map<int, const char*> _ELKNS_ImageFormats_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kELKNS_ImageFormatsValues, _kELKNS_ImageFormatsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kELKNS_RelayTypesValues[] = {
  ELKNS_RelayTypes::GRANT_RELAY,
  ELKNS_RelayTypes::DENY_RELAY
};
const char* _kELKNS_RelayTypesNames[] = {
  "GRANT_RELAY",
  "DENY_RELAY"
};
const std::map<int, const char*> _ELKNS_RelayTypes_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kELKNS_RelayTypesValues, _kELKNS_RelayTypesNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* Iris::ascii_fingerprint = "343DA57F446177400B333DC49B037B0C";
const uint8_t Iris::binary_fingerprint[16] = {0x34,0x3D,0xA5,0x7F,0x44,0x61,0x77,0x40,0x0B,0x33,0x3D,0xC4,0x9B,0x03,0x7B,0x0C};

uint32_t Iris::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->m_iris_code);
          this->__isset.m_iris_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->m_iris_mask);
          this->__isset.m_iris_mask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->m_iris_type);
          this->__isset.m_iris_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Iris::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Iris");

  xfer += oprot->writeFieldBegin("m_iris_code", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->m_iris_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("m_iris_mask", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->m_iris_mask);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("m_iris_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->m_iris_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Iris &a, Iris &b) {
  using ::std::swap;
  swap(a.m_iris_code, b.m_iris_code);
  swap(a.m_iris_mask, b.m_iris_mask);
  swap(a.m_iris_type, b.m_iris_type);
  swap(a.__isset, b.__isset);
}

const char* ActivityLog::ascii_fingerprint = "59BAC27122966B3FA058EFE417BDA97C";
const uint8_t ActivityLog::binary_fingerprint[16] = {0x59,0xBA,0xC2,0x71,0x22,0x96,0x6B,0x3F,0xA0,0x58,0xEF,0xE4,0x17,0xBD,0xA9,0x7C};

uint32_t ActivityLog::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Log_id);
          this->__isset.Log_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->email);
          this->__isset.email = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->m_host_machine);
          this->__isset.m_host_machine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->m_Act_type);
          this->__isset.m_Act_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->m_Act_Desc);
          this->__isset.m_Act_Desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->m_timeStamp);
          this->__isset.m_timeStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActivityLog::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ActivityLog");

  xfer += oprot->writeFieldBegin("Log_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->Log_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("email", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->email);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("m_host_machine", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->m_host_machine);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("m_Act_type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->m_Act_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("m_Act_Desc", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->m_Act_Desc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("m_timeStamp", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->m_timeStamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActivityLog &a, ActivityLog &b) {
  using ::std::swap;
  swap(a.Log_id, b.Log_id);
  swap(a.email, b.email);
  swap(a.m_host_machine, b.m_host_machine);
  swap(a.m_Act_type, b.m_Act_type);
  swap(a.m_Act_Desc, b.m_Act_Desc);
  swap(a.m_timeStamp, b.m_timeStamp);
  swap(a.__isset, b.__isset);
}

const char* EyelockNanoDeviceException::ascii_fingerprint = "D3BA2D33C1BA9DD4F2FDDA18F1640BC8";
const uint8_t EyelockNanoDeviceException::binary_fingerprint[16] = {0xD3,0xBA,0x2D,0x33,0xC1,0xBA,0x9D,0xD4,0xF2,0xFD,0xDA,0x18,0xF1,0x64,0x0B,0xC8};

uint32_t EyelockNanoDeviceException::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->custom_error = (Error_Code::type)ecast0;
          this->__isset.custom_error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->what);
          this->__isset.what = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->why);
          this->__isset.why = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EyelockNanoDeviceException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("EyelockNanoDeviceException");

  xfer += oprot->writeFieldBegin("custom_error", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->custom_error);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("what", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->what);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("why", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->why);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EyelockNanoDeviceException &a, EyelockNanoDeviceException &b) {
  using ::std::swap;
  swap(a.custom_error, b.custom_error);
  swap(a.what, b.what);
  swap(a.why, b.why);
  swap(a.__isset, b.__isset);
}

const char* GetIntReturn::ascii_fingerprint = "9C2A05F173B50306037BDE9AE30E1B99";
const uint8_t GetIntReturn::binary_fingerprint[16] = {0x9C,0x2A,0x05,0xF1,0x73,0xB5,0x03,0x06,0x03,0x7B,0xDE,0x9A,0xE3,0x0E,0x1B,0x99};

uint32_t GetIntReturn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetIntReturn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GetIntReturn");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetIntReturn &a, GetIntReturn &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* GetDoubleReturn::ascii_fingerprint = "0B663F1913C9C6F43150B524A8B76386";
const uint8_t GetDoubleReturn::binary_fingerprint[16] = {0x0B,0x66,0x3F,0x19,0x13,0xC9,0xC6,0xF4,0x31,0x50,0xB5,0x24,0xA8,0xB7,0x63,0x86};

uint32_t GetDoubleReturn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetDoubleReturn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GetDoubleReturn");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetDoubleReturn &a, GetDoubleReturn &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* GetBoolReturn::ascii_fingerprint = "4DC0C1A1F380340B40244ADC7FB0BA60";
const uint8_t GetBoolReturn::binary_fingerprint[16] = {0x4D,0xC0,0xC1,0xA1,0xF3,0x80,0x34,0x0B,0x40,0x24,0x4A,0xDC,0x7F,0xB0,0xBA,0x60};

uint32_t GetBoolReturn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetBoolReturn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GetBoolReturn");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetBoolReturn &a, GetBoolReturn &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* GetStrReturn::ascii_fingerprint = "3F5FC93B338687BC7235B1AB103F47B3";
const uint8_t GetStrReturn::binary_fingerprint[16] = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

uint32_t GetStrReturn::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetStrReturn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GetStrReturn");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetStrReturn &a, GetStrReturn &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

} // namespace
