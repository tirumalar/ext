/* ========================================
 *
 * NanoNXT Breakout Board
 * Copyright Eyelock.Inc, 2014, 2015
 * All Rights Reserved
 * UNPUBLISHED, LICENSED SOFTWARE.
 * CONFIDENTIAL AND PROPRIETARY INFORMATION
 * 
 * Version History:
 * ================
 * 3.0.0 : Ported Nano Breakout board functionality without HID/F2F.
 * 3.0.1 : Relay output moved from regular output mode to auxillary output mode
 * 3.0.2 : F2F functionality Added.
 * 3.0.3 : HID functionality added using SW UART for 26 bit weigand & SW UART tested on PAC comaptibilty 
 * 3.0.4 : Tamper In is directly routed to Tamper out
 * 3.0.5 : Software Reset button functionality added
 * 3.0.6 : HID functionality modified to support all types of weigand bit formats. 
 * 3.0.7 : Bootloader functionality added.
 * 3.0.8 : Reed Tamper Inverted for Beta.
 * 3.0.9 : Ported code for ICM 3(PSOC 5).
 * 3.1.0 : Bootloader functionality added to ICM3.
 * 3.1.1 : GRI 1-13-15: Tamper signals repaired. Tamper moved to main code block.  Tamper polarity added.
 * 3.1.2 : GRI 1-28-15: Tamper moved to HandleInputs.  I2C bus clock was corrected to be 100kHz to match motherboard (was 400kHz).
 * 3.1.3 : GRI 1-30-15: Removed all "ClearBuffer()" instances.
 * 3.1.4 : GRI 2-02-15: Added ACK bit for card reads to prevent hanging after card read. PSoC will wait for ACK for 5 sec, then re-notify MB.  Changed TamperTimer period to 1ms. 
 * 3.1.5 : GRI 2-04-15: Extensive revision to input signal handler to add noise immunity/debounce (see end of inout.c).
 * 3.1.6 : Added F2F card reader functionality
 * 3.1.7 : Debouncer added to WD0 && Functionality added to detect pulsewidth in F2F
 * 3.1.8 : Added F2F conditionality to turn on timers
 * 3.1.9 : Fixed the bootloader bug for PSOC creator 3.1  Use the debug NxtICM3_bootloader for reference
 * 3.1.10 : Make F2F pulse timing adaptive to the input signal
 * 3.1.15 : OSDP Dual Authentication
 * 3.1.16 : support F2F variable length messages
 * 3.2.0 : Fix F2F to accommodate prompt signal ATH-870
 * 3.2.1 : support Tamper Out Polarity Settings in the Web
 * 3.2.2 : reverse the tamper output polarity
 * 3.2.3 : 16 bits I2C
 * 3.2.4 : branched from 3.2.2, fixed pulse width narrowed by tamper interrupt problem
 * 3.2.5 : help firmware set the card in status again in one second if no ack comming.
 * 3.3.2 : same as 3.2.5 for GA release

 * ========================================
*/
#include <project.h>
#include "system.h"
#include "wiegand.h"
#include "power.h"
#include "inout.h"
#include "i2cuart.h"
#include "osdp.h"
#include "toc.h"

I2C_Regs MyI2C_Regs;
char run_mode;

void SU_Isr(SOFT_UART_STRUCT *s);
void HandleOSDP(void); 
void ReadImageCard(void);

/***********************************
    Sets the breakout board version.
*************************************/
void SetVersion()
{
    MyI2C_Regs.hw_version[0] = 0x71;
    MyI2C_Regs.hw_version[1] = 0x42;
    MyI2C_Regs.hw_version[2] = 0x0A;
    
    MyI2C_Regs.sw_version[0] = 3;
    MyI2C_Regs.sw_version[1] = 4;
    MyI2C_Regs.sw_version[2] = 1;
}


/*************************************
    Triggers Relay 1 as main output
    in msecs. (Functionality not used now)     
**************************************/
void TriggerRelay1(int waitMSecs)
{
    
    LED_GRN_Write(ON) ;
    LED_YEL_Write(ON);
	RELAY_A_Write(1);
	CyDelay(waitMSecs);
	LED_GRN_Write(OFF) ;
    LED_YEL_Write(OFF) ;
	RELAY_A_Write(0);
	
}

/*************************************
    Triggers Relay 2 as main output
    in msecs. (Functionality not used now)     
**************************************/

void TriggerRelay2(int waitMSecs)
{
    RELAY_B_Write(0);
    LED_GRN_Write(ON) ;
    LED_YEL_Write(ON);
	RELAY_B_Write(1);
	CyDelay(waitMSecs);
	LED_GRN_Write(OFF) ;
    LED_YEL_Write(OFF) ;
	RELAY_B_Write(0);
	
}


/**************************************
  Debug Method: To Set I2C data buffer
***************************************/
void SetBuffer()
{
    MyI2C_Regs.buffer[0] = 0x02;
    MyI2C_Regs.buffer[1] = 0x32;
    MyI2C_Regs.buffer[2] = 0x30;
    MyI2C_Regs.buffer[3] = 0x42;
    MyI2C_Regs.buffer[4] = 0x35;
    MyI2C_Regs.buffer[5] = 0x32;
    MyI2C_Regs.buffer[6] = 0x36;
    MyI2C_Regs.buffer[7] = 0x42;
    MyI2C_Regs.buffer[8] = 0x35;
    MyI2C_Regs.buffer[9] = 0x42;
    MyI2C_Regs.buffer[10] = 0x31;
    MyI2C_Regs.buffer[11] = 0x77;

}

void ClearBuffer()
{
    int i;
    for(i=0; i < 20; i++)
      MyI2C_Regs.buffer[i] = 0;
}

/***********************************************
            Weigand -HID Protocol
  Procedure to send weigand data in serial format
  Baud Rate: 57600 Databits: 8 
  Stop Bits: 2 Parity: Even 
  Bits to transmit : 18 bytes
  Zero paddings to the left before the weigand data 

************************************************/

void SendHID_SP533()
{
    int len;
    len = (MyI2C_Regs.data_length[0] << 8) + MyI2C_Regs.data_length[1];
    Clock_5_SetDividerValue(CLKDV_9600); //set the baud rate to default 9600
    UART_ACS_Init();
    CyDelay(20);
    Mode_Sel_ACS_Write(0); //set io chip to RS232
    TX_EN_Write(1);
    UART_ACS_LoadTxConfig();
    CyDelay(1); //Driver Output Enable Time, do not reduce. 
    UART_ACS_PutArray(MyI2C_Regs.buffer,len/8); 
    CyDelay(5); //minmum 4m
    UART_ACS_LoadRxConfig();
    TX_EN_Write(0);

}


void SendHID()
{
    Tamper_Timer_Stop();
    
    char serialOut[20];
	char tmp;
	int i,j;
	int padBytes;
    int xbytes;
    int ybits;
    MyI2C_Regs.data_length[0] = 0;
    MyI2C_Regs.data_length[1] = 26;
    xbytes =  MyI2C_Regs.data_length[1]/8;
    ybits =   MyI2C_Regs.data_length[1] - (xbytes*8);
    padBytes = 18  -  xbytes;
    
    if(ybits  >  0)
	   padBytes = padBytes - 1;
    
    for (i = 0;i < padBytes;i++)
    {
       serialOut[i] = 0x00;
       SU_PutChar(&s,serialOut[i]);
    }
	
    serialOut[14] = 0x01 << ybits;
	tmp = MyI2C_Regs.buffer[0] & (0xFF << (8-ybits));		
    tmp = tmp >> (8-ybits);
	serialOut[i] |= tmp; 
	SU_PutChar(&s,serialOut[i]);
	i++;
		
	for (j = 1; j< (18- padBytes); j++)
	{
		serialOut[i] = (MyI2C_Regs.buffer[j-1] << ybits );// & (0xFF << ybits);
		tmp = (MyI2C_Regs.buffer[j] >> (8-ybits));// & (0xFF >> (8-ybits));
		serialOut[i] |= tmp;
		SU_PutChar(&s,serialOut[i]);
		i++;
	}
    
    Tamper_Timer_Start();    
    serialOut[i] = 0x00;
}


void InitOSDP(){
    
    //initialize the OSDP
    Clock_5_Enable();
    Clock_5_SetDividerValue(CLKDV_9600); //set the baud rate to default 9600
    UART_ACS_Start();
    ClearOsdpBuffer();
    
    Clock_6_Enable();
    Clock_6_SetDividerValue(CLKDV_9600); //set the baud rate to default 9600
    UART_READER_Start();
    ClearOsdpReaderBuffer();
    
    isr_keepalive_StartEx(KeepAliveInterruptHandler);
    OSDPReaderTimer_Start();
    
}

 /***********************************************
     Debug Code : Software UART for PAC Protocol
  ************************************************
 void SendPACTest()
{
      int i,j;
    LED_GRN_Write(ON);
    LED_YEL_Write(OFF);
  
    for( i = 0; i < 20; i++)
    {
        for( j= 0; j < 12 ; j++)
        {
            char c = MyI2C_Regs.buffer[j];
         SU_PutChar(&s,c);
        }
      
    }

    LED_GRN_Write(OFF);
    LED_YEL_Write(OFF);
}

****************************************************/

void displayError(int n){
int i;
    for (i = 0; i< n; i++) 
    {
        LED_RED_Write(OFF); //display error
        CyDelay(300);
        LED_RED_Write(ON);
        CyDelay(300);
    } 
}

//char osdp_mode;
//char f2f_mode;
unsigned char f2f_alive_message[] = {0x0,0x34,0xE3,0xFD,0xA0,0x0,0x0,0x0,0x0};
char image_mode;
/****************************************
   Method to handle commands
   coming from device

*****************************************/
void HandleCommand()
{
    char cmd;
    int len;
    cmd = MyI2C_Regs.cmd;
//debug    cmd = CMD_IMAGE; //debug
    run_mode = MyI2C_Regs.mode;
    len = (MyI2C_Regs.data_length[0] << 8) + MyI2C_Regs.data_length[1];
    
    // process mode
    switch (run_mode)
    {
        case MODE_OSDP:
            if(0==isr_keepalive_GetState())
            {
                InitOSDP();
            }
            HandleOSDP();
            return;
        case MODE_F2F:
            if (f2f_send_alive)
            {
                SendF2F(f2f_alive_message,5);
                Tamper_Timer_ISR_Disable();
                f2f_send_alive = 0;
                f2f_alive_delay_cnt = 0;
                Tamper_Timer_ISR_Enable();
            }
            break;
        default:;
    }    
    
	switch (cmd)
    {
        case CMD_NONE:
                if (MyI2C_Regs.osdp_cmd != OSDP_NONE)
                {
                    return;
                }
                break;
        case CMD_BOOTLOAD:
                BootloadableI2C_Load();  //yqh
                break;
        case CMD_READ:
                Pass_Control_Write(0);  //not pass mode
                switch ( run_mode )
                {
                    case MODE_WIEGAND:
                        LED_GRN_Write(OFF);
                        OptSelect_Write(1);
                        ClearBuffer(); // added here - GRI 2/2/15
                        while(ReadWeigand(MyI2C_Regs.bits) == 0)
                        {
                            if(MyI2C_Regs.cmd !=CMD_READ ) 
                                break;
                        };
                        LED_GRN_Write(ON);
                        break;
                    case MODE_PAC:
                        LED_GRN_Write(OFF);
                        ClearBuffer(); // added here - GRI 2/2/15
                        SetupUART(PAC);
                        while(ReadPAC()== 0)
                        {
                            if(cmd != CMD_READ )
                            break;
                        }
                        LED_GRN_Write(ON);
                        OptSelect_Write(1);
                        break;
                    case MODE_F2F:
                        LED_GRN_Write(OFF);
                        OptSelect_Write(3);  //2=cut off UART1
                        while(ReadF2F() == 0)
                        {
                            if( MyI2C_Regs.cmd != CMD_READ ) 
                                break;
                        };
                        LED_GRN_Write(ON);
                        break;
                    case MODE_OSDP:
                        break;
                    case BASE_TOC + MODE_WIEGAND:
                        Pass_Control_Write(0);
                        if (image_mode == 0)
                        {
                            initReaderUART();
                        }
                        image_mode = 1;
                        ReadImageCard();
                        break;
                    default:
                        break;
                }
                break;
	    case CMD_SEND:
                Pass_Control_Write(0);  //not in pass mode
                switch( run_mode )
                {
                    case MODE_PAC:
                    case MODE_PAC + BASE_TOC:
                        LED_YEL_Write(OFF);
                        SetupUART(PAC);
                        SendPAC();
                        MyI2C_Regs.cmd = CMD_NONE;
                        LED_YEL_Write(ON);
        				break;
                        
                    case MODE_F2F:
                    case MODE_F2F + BASE_TOC:
                        Tamper_Timer_ISR_Disable();
                        f2f_send_alive = 0;
                        f2f_alive_delay_cnt = 0;
                        Tamper_Timer_ISR_Enable();
                        
                        OptSelect_Write(1);
        				SendF2F(MyI2C_Regs.buffer, len);
                        MyI2C_Regs.cmd = CMD_NONE;
                        
        			    break;        
                        
                    case MODE_HID:
                    case MODE_HID + BASE_TOC:
                       LED_YEL_Write(OFF);
                       OptSelect_Write(1);
        //               SendHID_SP533();
                       SendHID();
                       MyI2C_Regs.cmd = CMD_NONE;
                       LED_YEL_Write(ON);
        			   break;
                    
                    case MODE_WIEGAND:
                    case MODE_WIEGAND + BASE_TOC:
                        LED_YEL_Write(ON);
                        OptSelect_Write(1);
            			SendWeigand(MyI2C_Regs.bits);
                        MyI2C_Regs.cmd = CMD_NONE;
                        LED_YEL_Write(OFF);
        				break;  
                    case MODE_PAC + BASE_PASS:
                    case MODE_F2F + BASE_PASS:
                        Pass_Control_Write(1);
                        break;
                    case MODE_WIEGAND + BASE_PASS:
                        Pass_Control_Write(3);
                        break;
                    case MODE_OSDP + BASE_PASS:
                        Pass_OSDP();
                        break;
                    
                    default:
                        //displayError(100);
                        break;
                }
                break;
        default:;   //cmd
	}     
}

extern int rxi;
void ReadImageCard()
{
    int k;
    if(image_ready == 1)
    {
        image_ready = 0;
        if (rxi == 0) return; //wrong size
        if (rxi <= IMAGE_TEMP_SIZE )
        {
            for (k=0; k<rxi; k++)
            {
                MyI2C_Regs.buffer[k] = RxBuffer[k];
                CyDelayUs(1);   //needed for Release Codes
            }
            rxi = 0;  //ready for next image
            MyI2C_Regs.data_length[0]= k>>8;   //higher 8 bits
            MyI2C_Regs.data_length[1]= k;        //lower 8 bits.
            MyI2C_Regs.dummy0[0]= (k>>8) & 0xFF;   //higher 8 bits
            MyI2C_Regs.dummy0[1]= k & 0xFF;        //lower 8 bits.
            card_ack = 0;
            card_in_buf = 1;
            MyI2C_Regs.status |= STAT_CHANGE | STAT_CARD_IN;
            MyI2C_Regs.cmd = CMD_NONE; //prevent to read it again
        }
        else
        {
            rxi = 0; //data is too big, read again
        }
    } //if
}


int main()
{
    /* Intializing the variables */
//    char cmd;
//    int wait_for_ack; // card read acknowledge
    int ack_time_cnt; // counter for acknowledge timeout
    
    CyGlobalIntEnable;  /* Uncomment this line to enable global interrupts. */

//    /* Intializing the Timers and interrupts */
    UART_TIMER_Start();
	UART_TIMER_ISR_StartEx(UART_TIMER_ISR_Interrupt);
    Tamper_Timer_Start();
    Tamper_Timer_ISR_StartEx(Tamper_Timer_ISR_Interrupt);
    Timeout_Timer_Start();
    Timeout_Timer_Isr_StartEx(Timeout_Timer_Isr_Interrupt);

    /*Wiegand*/
    Pulse_50us_Init();
    isr_50us_StartEx(Pin_50us_Reset);

    /*F2F*/
    isr_F2F_edge_StartEx(isr_F2F_edge_Interrupt);
    
	/* Starting EZI2C */
	EZI2Cs_Start();
    EZI2Cs_SetBuffer1(sizeof(MyI2C_Regs), sizeof(MyI2C_Regs), (volatile uint8 *) &MyI2C_Regs );
    
    /* Starting UART for PAC & HID */
    UART_1_Start();
    SU_Start(&s,1,PARITY_EVEN,1);
    
    /* Turning off both LEDS */
    LED_GRN_Write(OFF); // LED for signaling Output
    LED_YEL_Write(OFF); // LED for signaling Input
    LED_RED_Write(OFF); // turn off tamper LED
    
    /* Intializing the I2C Reg value */
    MyI2C_Regs.factory_reset = 0;
    SetHardwareVals(TAMPERCR_POL);  // TAMPER_POL defaulted to 1 (normal config with active tamper = 0)
    
    SetVersion();
    
    // initialize card reader tamper polarity bit:  1=normal
    // This is only for TEST and must be set by webconfig/motherboard.
    // tamperCR_polarity = 1;
    image_mode = 0;
    card_ack = 0;
    
    InitOSDP();
    
    /* push button */
    buttonPressed=0;
    buttonReleased=0;
    buttonDuration=0;
    isr_SW_Rst_Start(); 
    
    while(1)
    {
        HandleCommand();
        if (card_in_buf == 1)  // card read requires ack from motherboard
        {
            ack_time_cnt = 0;
            while (card_ack == 0)   // waiting for card read acknowledge here
            {
                CyDelay(10);    //
                ack_time_cnt++;  // increment time counter every 10ms while waiting for ack
                if (ack_time_cnt >= 100)    //  re-notify and break.
                {
                    MyI2C_Regs.status |= STAT_CHANGE | STAT_CARD_IN ;   // if timeout, set status bit a second time to notify motherboard
                    break;
                }
            }
        } 

        if (run_mode == MODE_OSDP || MyI2C_Regs.mode == BASE_TOC + MODE_WIEGAND) CyDelay(0); //OSDP and TOC
        else CyDelay(50);    //up to 50ms Sec delay for sending out signals. 
    } //main loop
}

/* [] END OF FILE */
