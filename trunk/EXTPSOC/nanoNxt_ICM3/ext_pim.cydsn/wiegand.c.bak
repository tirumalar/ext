/* ========================================
 *
 * Copyright YOUR COMPANY, THE YEAR
 * All Rights Reserved
 * UNPUBLISHED, LICENSED SOFTWARE.
 *
 * CONFIDENTIAL AND PROPRIETARY INFORMATION
 * WHICH IS THE PROPERTY OF your company.
 *
 * ========================================
*/

// GRI 2-2-15: Modified ReadWiegand.

#include <project.h>
#include <D1_Reg.h>
#include "system.h"
#include "wiegand.h"
#include "Pulse_50us.h"

CY_ISR(Pin_50us_Reset)
{
    OptSelect_Write(2);
	D1Reg_Write(0);
    isr_50us_GetState();
    Pulse_50us_ReadStatusRegister();
    Pulse_50us_RestoreConfig();
    Pulse_50us_Init();
}
void send_D0_50us_pulse()
{
    OptSelect_Write(3); 
    Pulse_50us_Enable();
}
void send_D1_50us_pulse()
{
    D1Reg_Write(1);
    Pulse_50us_Enable();
}

void SendWeigand(int nBits)  //Function to send Wiegand Data
{
	int x,y;
	char  d1;
    char count = 0;
    
	/*                        Wiegand protocol
	    A pulse width of 50us to define data
	    A wait period of 2ms after transmitting the above defined pulse
    */
    OptSelect_Write(2);
    D1Reg_Write(0);
	for (x=0; x< 20; x++) // Loop over data written from the OMAP
	{
        d1 = MyI2C_Regs.buffer[x];
		for (y=0; y <8; y++)  //Transmit each bit at a time
		{	
			count++;
            if (count > nBits)
			{
				return;
			}

		    if (d1&0x80) // Check if it a 1 or a 0
			{
                send_D1_50us_pulse();
			}
			else
			{
                send_D0_50us_pulse();
			}			    
			d1=d1<<1;
            CyDelayUs(1430); //1430 = 2ms
		}
	}
}

/*

void SendWeigand(int nBits)  //Function to send Wiegand Data
{
	int x,y;
	char  d1;
    char count = 0;

    
	                        Wiegand protocol
	    A pulse width of 50us to define data
	    A wait period of 2ms after transmitting the above defined pulse
    */
	
/*
	for (x=0; x< 20; x++) // Loop over data written from the OMAP
	{
        d1 = MyI2C_Regs.buffer[x];
		for (y=0; y <8; y++)  //Transmit each bit at a time
		{	
			count = count + 1;
            if (count > nBits) //26 bit Wiegand; so terminate at 26 bits
			{
                OptSelect_Write(2);
			    D1_Reg_Write(0);
				return;
			}

		    if ((d1&0x80)) // Check if it a 1 or a 0
			{
                OptSelect_Write(2); //10 for select & D0
				D1_Reg_Write(1);
			}
			else
			{
                OptSelect_Write(3); //10 for select & D0
				D1_Reg_Write(0);
			}			    

            
            CyDelayUs(34);  //50us = 34
            
            OptSelect_Write(2);
			D1_Reg_Write(0);
			d1=d1<<1;
            
           
            CyDelayUs(1430);  //2ms = 1430

		}
        
	}
  
}
*/

int ReadWeigand(int nBits)
{
    int bitCount=0;
    int byteCount=0;
   
    char WD0 = Pin_WD0_Read() ;
    char WD1 = Pin_WD1_Read();
    card_in_buf = 0;
    
    if( WD0 == 0 || WD1 == 0)
    {
        while(byteCount*8+bitCount < nBits)
        {
           //Read D0 line for input, if yes wait for 50 usec for data to end
           WD0 = Pin_WD0_Read();
           WD1 = Pin_WD1_Read();
           if(WD0 == 0)
           {
             while(WD0 != 1){WD0 = Pin_WD0_Read();}
             
             bitCount++;

           }
        
            //Read D1 line for input, if yes wait for 50 usec for data to end
            //and write 1 to the bit in the buffer at the right position.            
           else if(WD1 == 0)
           {
             while(WD1 != 1){WD1 = Pin_WD1_Read();}
             MyI2C_Regs.buffer[byteCount] |= (0x01 << (7-bitCount));  //write a 1 to current buffer word 
             bitCount++;

           }
        
            //Reset bitCount
            if (bitCount > 7)
			{
				bitCount = 0;
				byteCount++;
			}
            
        }
        card_ack = 0;
        card_in_buf = 1;
        MyI2C_Regs.status |= STAT_CHANGE | STAT_CARD_IN ;
        MyI2C_Regs.cmd = CMD_NONE;
        return 1;
    }
    card_in_buf = 0;
    return 0;
}

/* F2F panel keep alive */
char f2f_send_alive;
int f2f_alive_delay_cnt;

void SendF2F(const unsigned char *buf, const int length)
{
	int x,b,z,len;
	char  d0;
	char aPRT0DRa;
	unsigned char f2f[28];
    char flag=0;
/*	//debug code	
    MyI2C_Regs.buffer[0] = 0;
    MyI2C_Regs.buffer[1] = 0xD1;
    MyI2C_Regs.buffer[2] = 0xE1;
    MyI2C_Regs.buffer[3] = 0xF9;
    MyI2C_Regs.buffer[4] = 0x80;
    MyI2C_Regs.data_length = 5;
*/    
    
    len = 3 + length;
    if(len > 12) len = 12; //
	//Loop over data written by OMAP, 40 bit no facility card
	//Zeros are transmitted as two transitions, with a pulse width of 1.1 ms
	//Ones are transmitted as four transitions, with a pulse width of 0.55 ms
	for (x=0; x< len; x++)
	{   	
		d0 = buf[x];	
        aPRT0DRa = 0;
		f2f[2*x] = 0;
		f2f[2*x + 1] = 0;		 
		for (b=0; b <4; b++)    //higher 4 bits
		{	   	  
			if (d0&0x80)    //it is a 1
			{      
				if (flag == 0)  //previous level is 0
				{	   	
					flag = 0;
					aPRT0DRa |= 0x02;	   	   		   
				}
				else            //previous level is 1
				{
					aPRT0DRa |= 0x01;
					flag = 1;
				}
			}
			else    //it is a 0
			{
				if (flag == 0)  //previous level is 0
				{
					aPRT0DRa |= 0x03;
					flag = 1;
				}
				else    //previous level is 1
				{
					flag = 0;
				}		   
			}

			if (b < 3)
				aPRT0DRa <<= 2; //go next bit

			d0 <<= 1;   //go next bit
		}
		f2f[2*x] = aPRT0DRa;

		aPRT0DRa = 0;	
		for (b=0; b <4; b++)    //lower 4 bits
		{	   	  
			if (d0&0x80)
			{      
				if (flag == 0)
				{	   	
					flag = 0;
					aPRT0DRa |= 0x02;	   	   		   
				}
				else
				{
					aPRT0DRa |= 0x01;
					flag = 1;
				}
			}
			else
			{
				if (flag == 0)
				{
					aPRT0DRa |=0x03;
					flag = 1;
				}
				else
				{
					flag = 0;
				}		   
			}

			if (b < 3)
				aPRT0DRa<<=2;

			d0<<=1;
		}
		f2f[2*x + 1] = aPRT0DRa;
	}

	//Use 8-bit timer to set up the pulse widths
	//Use the buffered data from above where we already set up the data specific pulses and send them out sequentially.
	aPRT0DRa = 0;
	for (z=0;z<2*len;z++)      //24
	{
		d0 = f2f[z];
		f2f[z]=0;
		for (b=0; b <8; b++)
		{
			if (d0&0x80)
            {
                PS_D0_Write(1);
                OptSelect_Write(2); 
			}
            else
            {
                OptSelect_Write(3);
                PS_D0_Write(0);
             }   
            CyDelayUs(400);
			d0<<=1;
		}
	}
    OptSelect_Write(2);
    PS_D0_Write(0);    //set output to high after done
}




int ReadF2F()
{
    int bitCount;
    int byteCount;
    int hp;
    char nbit;
    int i;
    unsigned char started;
    int width;
    
    // enable ack line
    D1Reg_Write(0);

    for(i =0; i < BUFFER_LENGTH; i++)
            MyI2C_Regs.buffer[i] = 0;
            
    hp = 21;  //21 17
    byteCount = 0;  
    nbit = 0;
    bitCount = 1;
    started = 0;
    card_in_buf = 0;
    while( byteCount <= 10 )
    {
        isr_F2F_edge_Disable();
        width = f2f_pulsewidth;             
        isr_F2F_edge_Enable();
        
        if(width > 0)
        {
            isr_F2F_edge_Disable();
            f2f_pulsewidth = 0;
            isr_F2F_edge_Enable();
            
            if (bitCount > 7)
            {
                bitCount = 0;
                byteCount++;
            }
 //           if(started == 0 && width > 7 && width < 0x40)
 //           {
 //               hp = (width + hp)>>1;  //average out
 //           }
            if(started == 1 && width >= ((int)(0.75*hp)) && width < 0x40 ) {
                nbit = 0;
                bitCount++;
            }
            /* A pulse width of 1msec is considered a 0 && two pulse widths of 0.5 msec is consdiered as 1
               Timeout timer is configured to update timeoutcnt every 50 usecs      */
            else if( width < ((int)(0.75*hp)))
            {
                nbit++;
                if(nbit > 1)
                {
                  MyI2C_Regs.buffer[byteCount] |= (0x01 << (7-bitCount));   
                  bitCount++;
                  nbit = 0; 
                  started = 1;
                }
            } 
            else if (width >= 0x40 && started == 1 )
            {
                break;
            }
        } //got pulse
    }  //while
    

    if(byteCount < 9)
    {
        MyI2C_Regs.data_length[0] = 0;  //stay at the f2f mode
        MyI2C_Regs.data_length[1] = 0;  //stay at the f2f mode
        card_in_buf = 0;
        return 0;
    }
    else
    {
//        for(i =0; i < 20; i++)  //debugging, yqh remove later
//            MyI2C_Regs.osdp_reader_buffer[i] = MyI2C_Regs.buffer[i];
        MyI2C_Regs.data_length[0] = 0;
        MyI2C_Regs.data_length[1] = 10;
        MyI2C_Regs.status |= STAT_CHANGE | STAT_CARD_IN ;
        card_in_buf = 1;
        card_ack = 0;
        MyI2C_Regs.cmd = CMD_NONE;  //to prevent send again
        return 1;
    }
}




/* [] END OF FILE */
